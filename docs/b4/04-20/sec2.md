# The Objective of Cryptography - 暗号化の目的

秘密を守ることだけが暗号化の目的ではない。暗号化はそれ以外にも以下のような問題も解決する。

1. **データの完全性** (*Data integrity*)

    受信者は受け取ったメッセージが伝送の途中で誤って、あるいは故意にメッセージが変更されたかどうかを確認出来る。

    元のメッセージの全体、または一部を偽のメッセージで置き換えることは出来ない。

2. **認証** (*Authentication*)

    受信者はそのメッセージの発信元を検証することが出来る。

    *Bob* 以外の人間が *Bob* だと偽って *Alice* にデータを送ることは出来ない。(*data origin authentication*)

    *Alice* と *Bob* は通信の開始時に互いの通信相手が確かにその人だと確認出来る。(*entity authentication*)

3. **否認不可** (*Non-repudiation*)

    送信者は後からメッセージを送ったことを否定できない。

もしメッセージが紙に書かれているならば、その媒体 (この場合 紙) はメッセージへの操作に対する一定の安全を保証する。
なぜならば手書きの署名は個人の認証と否認不可性を保証するからだ。

もしメッセージに電子メディアを用いた場合には、その媒体は一切の安全性を保証しない。
ネットワークでの伝送途中にメッセージの一部を改ざんすることはそう難しくない。特にインターネットのような公的にアクセス出来るネットワークではなおさらである。

そのため、暗号化には長い歴史があるが、電子通信におけるデータの完全性と認証を保証する技術の必要性は急速に高まっている。

公開鍵暗号方式のみならず対称鍵暗号方式についてもメッセージの完全性を保証するための手法がある。

古典的な対称鍵暗号方式は送信者と受信者の間で共有された秘密の鍵 $k$ を必要とする。

メッセージ $m$ には **メッセージ認証コード** (*MAC: message authentication code*) が付与される。
認証コードは一定のアルゴリズムに従って 鍵$k$ から生成される。

その認証コードの付与されたメッセージ $(m, MAC(k, m))$ は、改ざんに対して安全である。

受信者は、到着したメッセージ $(m, \bar{m})$ について以下の等式を調べることでその完全性を確認出来る。

$$ MAC(k, m) = \bar{m}. $$

メッセージ認証コードは鍵付きハッシュ関数で実装することが出来る。 (Chapter 2.)

**デジタル署名** (*Digital signatures*) は公開鍵暗号方式を必要とする。(Chapter 3.)

デジタル署名が契約に用いられる場合、公開鍵暗号方式の提供する否認不可性は不可欠な特性であることに注意しなければならない。

デジタル署名は署名者の秘密鍵に依存しているため、本人しか生成することが出来ない。
一方で、誰でも署名者の公開鍵に依存した既知の検証アルゴリズム *Verify* を適用することで、その署名の有効性を確認出来る。

*Alice* が メッセージ$m$ に署名したい場合、彼女の 秘密鍵$sk$ に署名のためのアルゴリズム $Sign$ を適用することで 署名 $Sign(sk, m)$ を得られる。

*Bob* は メッセージ$m$ の署名$s$ を受け取り、 *Alice* の 公開鍵$pk$ を用いた以下の式で署名の正当性を確認できる。

$$ Verify(pk, s, m) = ok. $$

メッセージ自体に署名するのではなく、まず**暗号学的ハッシュ関数** (*cryptographic hash function*, Section 2.2.) を適用してからそのハッシュ値に署名するのが一般的だ。

有名な **RSA** のような手法では、復号アルゴリズムは署名の生成に、暗号化アルゴリズムはその検証にそれぞれ用いられる。

> RSAはその発明者 Rivest, Shamir, Adleman の頭文字にちなんで名付けられた。

デジタル署名に対するこのアプローチは、しばしば *"hash-then-decrypt"*パラダイムと呼ばれる。(Section 3.3.5.)

デジタル署名はメッセージに依存する。メッセージが異なれば署名も異なる。

従って、古典的なメッセージ認証コードの様に、デジタル署名もまたメッセージの完全性を保証する。
