# Cryptographic Protocols - 暗号化プロトコル

暗号化アルゴリズムと復号アルゴリズム、暗号学的ハッシュ関数、疑似乱数生成器(*pseudorandom generators*) は秘密性と認証、データの完全性に関する問題を解決するための基本構造だ。

多くの場合、1つの基本構造のみでは問題の解決には不十分なため、複数の基本構造を組み合わせる必要がある。

与えられた課題を達成するための明確に定義された一連の流れを暗号化プロトコルと呼ぶ。
また、二人以上の当事者が関与しなければならない。

反例として、デジタル署名を考える。
典型的なデジタル署名の方法では、まずはじめに 暗号学的ハッシュ関数$h$ を メッセージ$m$ に適用する。
次に、その ハッシュ値$h(m)$ に 公開鍵$pk$ を使って復号アルゴリズムを適用、署名を得る。

2つのステップは1人で行えるため、これをプロトコルとは呼ばない。

プロトコルの典型例は、ユーザ識別のためのプロトコルだ。

ユーザを識別しなければならない状況は沢山ある。

*Alice* がリモートコンピュータにログインしたり、ネットバンキングのアカウントにアクセスしたいとする。

パスワードやPIN (Personal Identification Number) がこの目的のために使用される。
けれども、これらも全く安全なわけではない。

*Alice* がパスワードを送信するときに盗み見られてしまうとなりすますことが出来る。

*challenge and response* プロトコルは完璧とは言えないがこの攻撃を防げる。(Section 4.2.1.)

このプロトコルは公開鍵署名方式に基づいており、*Alice* が 鍵 $k = (pk, sk)$ を持っていると仮定する。

次の手順で *Alice* は *Bob* に対して自身の素性を証明できる。

1. *Bob* がランダムに "challenge" $c$ を決定し、 *Alice* に送信する。

2. *Alice* 秘密鍵を用いて $c$ に署名し、"response" として $s := Sign(sk, c)$ を *Bob* に送信する。

3. *Bob* は $Verify(pk, s, c) = ok$ であることを確認し、*Alice* の素性を証明する。

*Alice* のみが彼女の 秘密鍵$sk$ を知っているので、彼女だけが "challenge"$c$ の正しい署名を返せる。
そのため、*Alice* は自身の 秘密鍵$sk$ を示すことなく、自身の素性を証明できる。

*Alice* の正当性を証明した *Bob* を含め、誰も *Alice* の秘密鍵を盗み見ることは出来ない。

盗聴者 *Eve* が交換されたメッセージを傍受したとする。

その後、*Eve* は *Alice* になりすまそうと考えた場合にも、*Bob* は "challenge"$c$ をランダムに決定するので同じ "challenge" を2回使用する確率は非常に小さい。

従って、*Eve* は観察した情報から一切の利点を享受できない。

プロトコルやそれを成すアルゴリズムやその実装はあらゆる攻撃を受ける可能性がある。

鍵交換、電子投票、デジタルキャッシュ、同一性のインタラクティブな証明のための重要なプロトコルについては Chapter 4. で論じる。
