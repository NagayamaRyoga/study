# Provable Security - 証明可能安全性

暗号システムを設計するときには **証明可能安全** (*provably secure*) であることが望ましい。

**証明可能安全**とは、暗号システムがある種の攻撃を防げることを数学的に証明出来ることを言う。

この分野の先駆けとなる研究は *C.E. Shannon* によって行われた。

*Shannon* は メッセージに関連する情報の量 (the amount of information associated with a message) と 完全秘密 (perfect secrecy) という概念を初めて導入した。

完全秘密暗号 (*perfect secret* cipher) はあらゆる暗号文単独攻撃を完璧に防ぐ。
攻撃者は、例えマシンパワーと時間を無制限に使えたとしても平文に関する一切の情報を得られない。

*Vernam* の **ワンタイムパッド** (*one time pad*) (Section 2.1.1.) は、メッセージを真性乱数bit列とbit単位に XOR をとって暗号化するもので、もっとも有名な完全秘密暗号だ。

ワンタイムパッドは上のような受動的攻撃にさえ完全に耐える。

この安全性はシャノンの理論によって数学的に証明されている。

古典的な情報理論的安全性 (information-theoretic security) については Section 9.1. で論じる。

*Shannon* の情報理論については Appendix B を参照せよ。

あいにくと *Vernam* のワンタイムパッドを含む全ての完全秘密暗号は非実用的だ。

完全秘密に十分な長さの真性乱数bit列を生成して処理することは非現実的だ。

従って、近年の証明可能安全へのアプローチは、完全秘密への理想と非現実的な無限のマシンパワーの仮定を放棄する。
そのため、アルゴリズムに関する計算の複雑さも考慮しなければならない。

実際に 可能な (*feasible*) 攻撃のみが考慮される。

**可能** であるとは、攻撃が効率的なアルゴリズムによって実現されることを意味する。

当然のように、ここで効率の概念についての疑問が生じる。

確かに、非多項式実行時間であるアルゴリズムは効率的でない。

逆に、多項式実行時間のアルゴリズムは大抵効率的だと見做される。

暗号化手法に対する攻撃はランダムな出来事の影響を受けることもある。

攻撃者 *Eve* が次にどんな攻撃をするかコイントスで決めるかもしれない。
そのため、**確率的アルゴリズム** (*probabilistic algorithms*) は、攻撃者をモデル化するために使われる。

例えば暗号文単独攻撃によって暗号システムが破られるということは、多項式実行時間を有する確率的アルゴリズムが無視できないほどの確率で、暗号文から平文に関する情報を導き出せることを意味する。

確率的アルゴリズムは少なくとも部分的なランダム性に依るところがあるが、それを非決定論的アルゴリズムと混同してはいけない。

確率的多項式実行時間アルゴリズムの概念と、その根底にある確率的モデルについては Chapter 5. で論じる。

公開鍵暗号システムの安全性は、計算の困難さ (問題解決のための効率的な解法が存在しないこと) に基づいている。

例えば、RSA法の秘密鍵は巨大な整数 (現在のマシンパワーでは1024bitくらい) の素因数を計算が可能であれば容易に求めることが出来る。

しかしながら、巨大な整数の素因数分解は不可能と見做されている。

公開鍵暗号システムの計算上の攻撃に対する堅牢さは数学的に証明されているものではない。

従って、公開鍵暗号方式の安全性の根拠は常に条件付きであり、基礎となる仮定が妥当であることに依存する。

公開鍵暗号方式の仮定は通常ある関数 $f$ が一方向、すなわちある$x$ について効率的に $f(x)$ を計算出来るが、$f(x')$ から $x'$ の値を求められない、としている。

これらの仮定は、一方向関数の概念と同様に、確率的多項式アルゴリズムを使うことで非常に正確にすることが出来る。

> These assumptions, as well as the notion of a one-way function, can be made very precise by the use of probabilistic polynomial algorithms.

確率的多項式アルゴリズムによってうまく関数を逆変換される確率は 無視できるほど小さい (*negligibly small*)。(Chapter 6., Definition 6.12.)

本書には因数分解、離散対数、二次的残差仮説 (quadratic resduosity assumptions) などの重要な例が含まれている。(Chapter 6.)

*Shannon* の完全秘密には、**平文識別不能性** (*ciphertext indistinguishability*) (あるいは **意味論的安全性** (*semantic security*)) がある。

攻撃者の計算量にかかわらず、攻撃者が2つの平文 $m$ と $m'$ の区別がつかない場合に限り、暗号は完全秘密である。
攻撃者が暗号文 $c$ が $m$、$m'$ の暗号化であることを知っていれば $1/2$ の確率で正しいほうを選択する。

平文識別不能性 (**計算量的識別不能性** (*polynomial-time indistinguishability*)) は、攻撃者が正しい確率的多項式アルゴリズムを適用させる確率が精々 $1/2$ よりもほんのわずかに大きい程度であることを意味する。(Chapter 9, Definition 9.14.)

Section 9.4. では **公開鍵ワンタイムパッド** (*public-key one-time pads*) は識別不能であることが証明されている。

これは、例えば、RSA公開鍵ワンタイムパッドはRSA関数が一方向であるという唯一の仮定のもとで平文識別不能であることを意味する。

公開鍵ワンタイムパッドは、*Vernam* のワンタイムパッドに似ている。
相違点は、メッセージ $m$ が一方向関数によって短い真性乱数のシード値から生成された疑似乱数bit列とXORをとる点だ。

このことからわかるように、一方向関数は公開鍵暗号とデジタル署名のみでなく、計算上完全な疑似乱数生成器にとっても不可欠な要素だ。 (Chapter 8.)

$f$ が一方向関数である場合、$f(x)$ から $x$ を求めることが不可能であるだけでなく、$x$ の特定のbit (ハードコアビット (*hard-core bit*)) についても同様に推測をするのが困難だ。

この特性は、一方向関数のビット安全性 (*the bit security of a one-way function*) と呼ばれる。

例えば、最下位ビットは RSA関数 $x \mapsto x^e \; \rm{mod}$ $n$ のハードコアビットだ。

真性乱数のシード値から繰り返し $f$ を適用し、その毎にハードコアビット列をとると、疑似乱数bit列が得られる。

これらのbit列と真性乱数bit列を効率的なアルゴリズムで識別することは出来ない。
また、同様に前のbitから次のbitを予測することは事実上不可能である。(ヤオの定理 (*Yao's Theorem*)、Section 8.2.)
そのため、これらは計算上完全である。

重要な一方向関数のビット安全性については Chapter 7. で確率に関する詳細な分析を含めて検証されている。

ランダム性と暗号化方式の安全性は密接に関係している。

ランダム性の存在しない安全性はない。

暗号文が攻撃者に対しランダムに現れる場合にのみ暗号化手法は秘密を提供する。

> An encryption method provides secrecy only if the ciphertexts appear random to the adversary Eve.

*Vernam* のワンタイムパッドは完全秘密だ。なぜならば、真性乱数の鍵列 $k$ がために、暗号化されたメッセージ $m \oplus k$ は攻撃者にとっては真にランダムなbit列であるからだ。

公開鍵ワンタイムパッドは、攻撃者が効率的な識別アルゴリズムを使用している場合には結果として擬似乱数鍵列と真性乱数鍵列を識別出来ないため、平文識別不能である。

<!-- textlint-disable -->
公開鍵ワンタイムパッドは暗号文単独攻撃を行う受動的な盗聴者に対しては安全である。

しかし、*Bleichenbacher* 攻撃 (*Bleichenbacher*'s 1-Million-Chosen-Ciphertext Attack (Section 3.3.2.)) が証明しているように、適応的選択暗号文攻撃を実行する積極的攻撃者は現実的な脅威となりうる。

そのため、そのような攻撃に対する安全性も望まれる。

Section 9.5. では、適応的選択暗号文攻撃に堅牢な2つの公開鍵暗号方式とその安全性の証明について学ぶ。

公開鍵暗号方式のうちの1つである、*Cramer* と *Shoup* の公開鍵暗号方式は、安全性証明が数論的仮定とハッシュ関数 (衝突耐性) に関する標準仮定に基づいた最初の実用的な方式だった。

理想的な暗号学的ハッシュ関数は、**ランダム関数** (a *random function*) である。
ランダム関数は、ランダムに選択された一様分布の値と区別することの出来ないハッシュ値を生成する。

このようなランダム関数は **ランダムオラクル** (*random oracle*) とも呼ばれる。

暗号化方式の安全性は **ランダムオラクルモデル** (the *random oracle model*) で証明されることがある。
その証明は、想定される問題の計算強度に加えて、そのような方式で使用されるハッシュ関数が真性ランダム関数であるという仮定に依拠している。

そのような方式の例に、公開鍵暗号方式の OAEP (Section 3.3.3.) および SAEP (Section 9.5.1.)、 上述の署名方式 PSS、フルドメインハッシュRSA署名 (full-domain-hash RSA signatures) がある。
SAEPとフルドメインハッシュ署名のランダムオラクル証明を行う。
<!-- textlint-enable -->

真性ランダム関数は実装できない。
それどころか完全に近似することさえ出来ない。

そのため、ランダムオラクルモデルの証明は完全安全性の証明になることはない。

実際に使用されるハッシュ関数は、真性ランダム関数のいい感じの近似になるよう実装される。
しかし、過去には驚くような失敗もあった。(Section 2.2.)

私達は暗号化方式に対する様々な種類の攻撃を分類した。
同様の方法で、署名方式に対する攻撃を分類し、いくつかのセキュリティレベルを定義出来る。

この分類を Capter 11. で紹介し、標準的な仮定 (因数分解や強力なRSA仮定など) の基でしか安全性を証明できない署名方式の例を挙げる。
PSSのような方式とは違い、ハッシュ関数のランダム性についての仮定がなされなければならない。
与えられた署名方式では、例え攻撃者が適応的に選択したメッセージに対する有効な署名を正規の署名者から得ても、単一の署名を偽造できないことを示す。

公開鍵方式の安全性証明は常に条件付きであり (広く信じられているが証明されていない) 仮定に依存している。

一方で、*Shannon* の完全秘密の概念、特に *Vernam* のワンタイムパッドの完全秘密は条件に依らず常に成立する。

もちろん、無条件な完全安全はほとんどの実用的な状況では実現できないが、完全な情報理論上の安全に近づく実用的な暗号システムを設計する試みはなされてきた。
その証明は古典的な情報理論的方法に基づいており、証明されていない仮定には依存しない。

Capter 10. では、これらの暗号システムとそれに適用される手法について紹介する。

無条件の安全性に対する重要なアプローチは **量子暗号** (*quantum cryptography*) だ。
*Bennett* と *Brassard* の有名な BB84 プロトコルである **量子鍵配送** (*quantum key distribution*) について、安全性の証明を含めて詳しく説明している。

無条件に安全なメッセージ認証コード、*Rényi* エントロピーと秘匿性増幅について取り上げられている。
