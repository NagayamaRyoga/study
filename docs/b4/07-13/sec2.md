# 3.4 The Discrete Logarithm - 離散対数

[Section 3.3.](#TODO) では、RSA暗号方式について説明した。

RSA関数は要素 $m$ を $e$ 乗する。

これは全単射関数であり、効率的に計算できる。
しかし、$n$ の因数分解が不明のとき、$e$ 乗根を計算するための効率的なアルゴリズムは知られていない。

同じように、数論では簡単に計算できるが、原像を求めることの難しい関数が他にもある。

最も重要な関数は有限体における冪乗である。

$p$ を素数とし、$g$ を $\Z_p^*$ の原始根とする (Section A.4.)。

離散指数関数 $Exp$ は一方向関数である。

$$ Exp: \Z_{p-1} \longrightarrow \Z_p^*, \; x \longmapsto g^x $$

これは、[平方乗算法 (Algorithm A.27.)](../06-08/#algorithm-a-27-fast-modular-exponentiation-algorithm-) などによって効率的に求められるが、$Exp$ の逆関数 $Log$ を計算するための効率的なアルゴリズムは知られておらず、また、そのようなアルゴリズムは存在しないと広く考えられている。

この仮定は、**離散対数仮定** (*discrete logarithm assumption*) と呼ばれている。(正確な定義は Definition 6.1.)

## 3.4.1. ElGamal Encryption

RSA関数とは対照的に、$Exp$ は "抜け穴" のない一方向関数である。

$Exp$ は逆関数の計算を簡単に行うための付加的な情報を持たない。

それにも関わらず、$Exp$ は ElGamal 暗号方式の基礎となっている。([ElGamal84])

### Key Generation - 鍵の生成

メッセージの受信者 Bob は次のように準備をする。

1. $p-1$ が大きな素因数をもち、$\Z_p^*$ が原始根 $g$ を持つような大きい素数 $p$ を選ぶ。

2. $1 \le x \le p-2$ なる整数 $x$ をランダムに選ぶ。

    $(p, g, x)$ が Bob の秘密鍵となる。

3. $\Z_p$ 上の $y = g^x$ を計算する。

    $(p, g, y)$ が Bob の公開鍵となる。($x$ は依然として秘密である)

大きな素数 $q$ について、素数 $p$ が $p = 2kq+1$ を満たす場合、$p-1$ は大きな素因数を持つことになる。

従って、Bob はまず大きな素数 $q$ を選ぶ必要がある。
$q$ RSA 鍵の生成のときと同じ方法で求められる (Section 3.3.1.)。

続いて $p$ を得るために、適切なbit長の $k$ をランダムに選択し、確率的素数検定を $z = 2kq+1$ に適用する。
$z$ が素数でなかった場合には $k$ の値を $1$ ずつ増やしながら繰り返す。

最初の素数が得られるまで $O(\ln z)$ 回の検定が期待される (Corollay A.85.)。

素数 $p = 2kq+1$ が見つかったので、次に $\Z_p^*$ の要素 $g$ をランダムに選択し、$g$ が原始根であるかどうかを調べる。
この検定には $k$ の因数分解が必要になる (Algorithm A.40)。

従って、$k$ が効率的に因数分解できるよう (= $k$ が十分小さくなるよう)、 $q$ は十分大きなものを選択しなければならない。

ただし、$p-1$ のすべての素因数が小さな数であることは避けなければならない。
そのような場合には、Silver, Pohlig, Hellman によって発明された離散対数の効率的な計算アルゴリズムがある。 ([Koblitz94])
