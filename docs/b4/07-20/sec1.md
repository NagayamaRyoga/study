## Algorithm 3.6.

```
int A(int n, e, y)
1   t ∈ {1, ..., r} をランダムに選択する
    ht ← y
2   si ∈ Zn をランダムに選択する
    hi ← si^e (i=1,...,r  i≠t)
3   F(n, e) を呼ぶ
4   if Fが mi のハッシュ値を問い合わせるなら then hiを応答とする
5   if Fが mi (i≠t) の署名を要求するなら then siを応答とする
6   if Fが mt の署名を要求するなら then 失敗し終了
7   if Fが m' (i=1,...,r について m'≠mi) の署名を要求するなら then Znのランダムな要素を応答とする
8   if Fが (m, s) を返すなら then sを返す
```

1行目: $A$ は $F$ がこれから偽造する署名のメッセージ $m \in \{ m_1, ..., m_r \}$ を推測しようと試みる。

$F$ は $m$ のハッシュ値を知っていなければならない。

知らなければ $m$ のハッシュ値 $h(m)$ は $F$ とは独立してランダムに生成される。
その場合、$F$ によって生成された署名 $s$ が検証条件 $s^e \mod n = h(m)$ を満たす確率は $1/n$ であり、無視できるほど小さい。

そのため、$m$ は必然的に $F$ がハッシュ値を問い合わせるメッセージ $m_i$ のうちの1つである。

5行目: $F$ が $m_i \; (i=t)$ の署名を要求するなら、 $A$ は有効な署名 $s_i$ を応答する。

7行目: $F$ が $m' \neq m_i \; (i=1,...,r)$ の署名を要求するなら、$A$ は乱数を応答できる。

$F$ は返答の正当性を検証できない。

1行目で $A$ が正しい $m_t$ を推測し、$F$ が署名の偽造に成功したと仮定する。
そのとき、$F$ は $m_t$ の正しい署名 $s$ を返す。
すなわち、$s$ は $y$ の $e$ 乗根であり、$s^e = h(mt) = y$ を満たす。

この場合、$A$ は $s$ を返す。

1行目で $A$ が正しい $m_t$ を推測できる可能性は $1/r$ である。
すなわち、forger $F$ の成功確率を $0 \le \alpha \le 1$ とした場合、$A$ の成功確率は $1/r \cdot \alpha$ となる。 

forger $F$ が常に成功する ($\alpha = 1$) と仮定する。
$A$ の反復により、$1$ に近い確率で $e$ 乗根を計算できるアルゴリズムが得られる。

一般に、$F$ とほぼ同じ確率 $\alpha$ で $e$ 乗根を計算できるアルゴリズムが得られる。

フルドメインハッシュ RSA署名について学ぶことで、ランダムオラクルモデルの証明可能安全性について説明した。

証明は、ランダムオラクルモデルには完全な偽造者が存在し得ないことを示している。

しかし、現実のハッシュ関数が完璧なランダムオラクルであることは絶対にないため (Section 2.2.4.)、これらの議論は実際の署名方式の安全性証明にはなり得ない。
実際の署名方式には現実に存在するハッシュ関数の実装が使用されるからである。

Section 9.5. では、Boneh の SAEP 暗号方式のランダムオラクル証明を行う。

証明には、$\Z_n$ の各要素が同様の確率でハッシュ値として出力されるようなフルドメインハッシュ関数が必要である。
実際に使用されているハッシュ関数は通常、上で述べたようにフルドメインハッシュ関数ではない。

次節で説明する署名方式は、フルドメインハッシュ関数には依存しない。
その方式はハッシュ化されたメッセージを巧みに署名関数のドメインに埋め込む。

## PSS - The Probabilistic signature scheme

**PSS** (*The Probabilistic signature scheme* / 確率署名方式) が、[BelRog96] で紹介された。

この方式では、メッセージの署名はメッセージと、選択されたランダムな入力に依存する。
それゆえ、署名方式は確率的になる。

この方式には RSA 復号関数や Rabin の暗号システム の復号関数のような、公開鍵暗号方式の復号関数が必要である。 (Section 3.5.)

<!-- textlint-disable preset-ja-technical-writing/max-comma -->

より一般的には、トラップドア順列 (*trapdoor permutation*)

$$ f \; : \; D \longrightarrow D, \; D \subset \{ 0,1 \}^n, $$

疑似乱数 bit 生成器

$$ G \; : \; \{ 0,1 \}^l \longrightarrow \{ 0,1 \}^k \times \{ 0,1 \}^{n-(l+k)}, \quad w \longmapsto (G_1(w), G_2(w)) $$

そしてハッシュ関数

$$ h \; : \; \{ 0,1 \}^* \longrightarrow \{ 0,1 \}^l $$

が必要になる。

<!-- textlint-enable preset-ja-technical-writing/max-comma -->

PSS は任意の長さのメッセージに適用できる。

メッセージ $m$ は署名 $\sigma$ から復元することは出来ない。

### Signing - 署名

メッセージ $m \in \{ 0,1 \}^*$ を署名するために、署名者 Alice は以下の3工程で署名 $\sigma$ を生成する。

1. $r \in \{ 0,1 \}^k$ をランダムに選択し、$w := h(m \|\| r)$ を求める。

2. $G(w) = (G_1(w), G_2(w))$ と、$y := w \;\|\|\; (G_1(w) \oplus r) \;\|\|\; G_2(w)$ を計算する。

    ただし、$y \notin D$ なら 1. に戻る。

3. $m$ の署名は $\sigma := f^{-1}(y)$。

署名者 Alice がメッセージ $m$ に署名したい場合、まず乱数 $r$ をメッセージに連結し ($m \|\| r$)、ハッシュ関数 $h$ を適用する ($w := h(m \|\| r)$)。

次に、乱数生成器 $G$ をハッシュ値 $w$ に適用する。

$G(w)$ の $G_1(w)$ の部分は、乱数 $r$ を隠すために使用される。
$G_2(w)$ を $w \|\| G_1(w) \oplus r$ に結合して適切な長さの $y$ を得る
。
$y$ のすべての bit はメッセージ $m$ に依存する。

$m$ を $f$ のドメイン上で変換することにより写像 $m \longmapsto y$ はランダム関数のように振る舞う。
この仮定は署名方式の安全性を保証する。

最後に、$y$ を $f$ で復号して署名 $\sigma$ を得る。

乱数 $r$ は各メッセージ $m$ について独立に選択される。
そのため、同じメッセージを2回署名しても異なる署名が得られる。

### Verification - 検証

署名されたメッセージ $(m, \sigma)$ を検証するために、同様のトラップドア関数 $f$ と乱数生成器 $G$、ハッシュ関数 $h$ を用いる。

1. $f(\sigma)$ を計算し、$f(\sigma) = w \|\| t \|\| u$ に分解する。

    ただし、$|w| = l$, $|t| = k$, $|u| = n - (k+l)$ である。

2. 乱数 $r$ を $r = t \oplus G_1(w)$ で復元する。

3. $h(m \|\| r) = w$ かつ $G_2(w) = u$ ならば署名を受理する。

PSS は RSA 仮定のもとランダムオラクルモデルで安全であることが証明できる。
この証明では、ハッシュ関数 $h$ および $G$ がランダムオラクルであることを仮定する。

PSS の実際の応用では、$h$ と $G$ を SHA-1 や、衝突耐性の考慮されているその他の暗号学的ハッシュ関数で実装することが推奨されている。

典型的には $n = 1024 \rm{bit}$、 $k = t = 128 \rm{bit}$ である。
