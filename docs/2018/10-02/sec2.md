# II. Implementing embedding methods for C/C++ sources

C/C++プロジェクトのソースファイルに透かしを埋め込む、コンパイルの直前に実行される独立したプログラムの作成を検討する。
このようなものの場合、I.で挙げられている方法のうちどの方法が適切であろうか。

まず、コンパイラによって構築されるインポート/エクスポートテーブルに干渉することは明らかに困難である。
また、ソースコードを表現する命令の選択も主にコンパイラの役割であり、同じく干渉は困難である。

従って、実装するなら他の3つの方法からとなる。

命令スケジューリングは文の順序により、レジスタ・メモリ割り当ては宣言の順序である程度制御出来る。
コードレイアウトを変更することを可能ではあるが、最も複雑である。
さらにこの方法は特許によって保護されている。[1]

透かし埋め込みプログラムの最初のバージョンでは、文の順序付けとローカル変数の順序付けに専念した。

実装例を示す。次の関数を考える。

```c
int f (int x) {
    int a, b;
    a = x + 1;
    b = x - 1;
    return a + 2 * b;
}
```

関数の計算部分はGCCで以下のようにコンパイルされた。

```
ldr r3, [fp, #-16]
add r3, r3, #1
str r3, [fp, #-20]
ldr r3, [fp, #-16]
sub r3, r3, #1
str r3, [fp, #-24]
ldr r3, [fp, #-24]
mov r2, r3, asl #1
ldr r3, [fp, #-20]
add r3, r2, r3
mov r0, r3
```

変数のメモリ割り当ては、その宣言順に関係する。

```
x = [fp, #-16]
a = [fp, #-20]
b = [fp, #-24]
```

我々の手法によって、変数宣言と独立した文の順序によってこの関数に2bitの透かしを埋め込むことが出来る。

0: `int a, b;` <-> 1: `int b, a;`

0: `a = x+1; b = x-1;` <-> 1: `b = x-1; a = x+1;`

従って、変数宣言と文が辞書順になっている最初に挙げた関数は透かし`00`に対応する。

例えば透かし`11`を埋め込む場合、関数は

```c
int f (int x) {
    int b, a;
    b = x - 1;
    a = x + 1;
    return a + 2 * b;
}
```

となり、これは次のようにコンパイルされる。

```
ldr r3, [fp, #-16]
sub r3, r3, #1
str r3, [fp, #-20]
ldr r3, [fp, #-16]
add r3, r3, #1
str r3, [fp, #-24]
ldr r3, [fp, #-20]
mov r2, r3, asl #1
ldr r3, [fp, #-24]
add r3, r2, r3
mov r0, r3
```

このときの変数のメモリ割り当ては

```
x = [fp, #-16]
a = [fp, #-24]
b = [fp, #-20]
```

の様になる。

この手法の堅牢性について考える。

透かし`00`/`11`の埋め込まれた関数を含む実行可能ファイル/オブジェクトファイルがそれぞれあるとする。

`cmp -l`を用いてファイルを比較した場合、4箇所の相違点が見つかる。

```
 79: 203 103
 91: 103 203
 97:  30  24
105:  24  30
```

(`203`/`103`の違いは`add`/`sub`命令の違いに,`30`/`24`の違いは変数`a`/`b`の割り当ての違いに現れる。)

それぞれのバイトを変更することによって、この透かしを`01`/`10`へと改ざんすることは出来ないことに注意する。
例えば、`203`/`103`を交換した場合、関数は`b`に`1`を加算し`a`から`1`を減算するため関数の出力が破綻する。

相違点を見つけたバイトを単に変更するだけでは透かしの改竄は出来ないと言える。

これらの違いは、透かしの位置を検出するのに役立つ。
もちろんそれを検出出来るのは、ソフトウェアパッケージが異なる透かしで配布され、悪意あるユーザが連合を作成したときに限られる。
