# II. Implementing embedding methods for C/C++ sources

C/C++プロジェクトのソースファイルに透かしを埋め込む、コンパイルの直前に実行される独立したプログラムの作成を検討する。
このようなものの場合、I.で挙げられている方法のうちどの方法が適切であろうか。

まず、コンパイラによって構築されるインポート/エクスポートテーブルに干渉することは明らかに困難である。
また、ソースコードを表現する命令の選択も主にコンパイラの役割であり、同じく干渉は困難である。

従って、実装するなら他の3つの方法からとなる。

命令スケジューリングは文の順序により、レジスタ・メモリ割り当ては宣言の順序である程度制御出来る。
コードレイアウトを変更することを可能ではあるが、もっとも複雑である。
さらにこの方法は特許によって保護されている。[1]

透かし埋め込みプログラムの最初のバージョンでは、文の順序付けとローカル変数の順序付けに専念した。

実装例を示す。次の関数を考える。

```c
int f (int x) {
    int a, b;
    a = x + 1;
    b = x - 1;
    return a + 2 * b;
}
```

関数の計算部分はGCCで以下のようにコンパイルされた。

```
ldr r3, [fp, #-16]
add r3, r3, #1
str r3, [fp, #-20]
ldr r3, [fp, #-16]
sub r3, r3, #1
str r3, [fp, #-24]
ldr r3, [fp, #-24]
mov r2, r3, asl #1
ldr r3, [fp, #-20]
add r3, r2, r3
mov r0, r3
```

変数のメモリ割り当ては、その宣言順に関係する。

```
x = [fp, #-16]
a = [fp, #-20]
b = [fp, #-24]
```

我々の手法によって、変数宣言と独立した文の順序によってこの関数に2bitの透かしを埋め込むことが出来る。

0: `int a, b;` <-> 1: `int b, a;`

0: `a = x+1; b = x-1;` <-> 1: `b = x-1; a = x+1;`

従って、変数宣言と文が辞書順になっている最初に挙げた関数は透かし`00`に対応する。

例えば透かし`11`を埋め込む場合、関数は

```c
int f (int x) {
    int b, a;
    b = x - 1;
    a = x + 1;
    return a + 2 * b;
}
```

となり、これは次のようにコンパイルされる。

```
ldr r3, [fp, #-16]
sub r3, r3, #1
str r3, [fp, #-20]
ldr r3, [fp, #-16]
add r3, r3, #1
str r3, [fp, #-24]
ldr r3, [fp, #-20]
mov r2, r3, asl #1
ldr r3, [fp, #-24]
add r3, r2, r3
mov r0, r3
```

このときの変数のメモリ割り当ては

```
x = [fp, #-16]
a = [fp, #-24]
b = [fp, #-20]
```

の様になる。

この手法の堅牢性について考える。

透かし`00`/`11`の埋め込まれた関数を含む実行可能ファイル/オブジェクトファイルがそれぞれあるとする。

`cmp -l`を用いてファイルを比較した場合、4箇所の相違点が見つかる。

```
 79: 203 103
 91: 103 203
 97:  30  24
105:  24  30
```

(`203`/`103`の違いは`add`/`sub`命令の違いに,`30`/`24`の違いは変数`a`/`b`の割り当ての違いに現れる。)

それぞれのバイトを変更することによって、この透かしを`01`/`10`へと改ざんすることは出来ないことに注意する。
例えば、`203`/`103`を交換した場合、関数は`b`に`1`を加算し`a`から`1`を減算するため関数の出力が破綻する。

相違点を見つけたバイトを単に変更するだけでは透かしの改竄は出来ないと言える。

これらの違いは、透かしの位置を検出するのに役立つ。
もちろんそれを検出出来るのは、ソフトウェアパッケージが異なる透かしで配布され、悪意あるユーザが連合を作成したときに限られる。

実行可能ファイルを逆アセンブルすると、より深刻な攻撃が実行されうる。
実際の大きな実行可能ファイルを逆アセンブルして分析するのは難しい作業だが、ソースレベルでのC/C++への透かしの埋め込みにはさらに複雑な問題がある。

関数のアセンブリコードを見ると、最初に透かしを改ざんするために並び替えることが出来る連続した独立の命令列は無いことがわかる。
一般に、独立したC/C++の文は単一の命令にコンパイルされるのではなく、独立した命令グループにコンパイルされるためである。

したがって、より高レベルの言語の文に対応する命令のグループを決定するためには、追加の逆アセンブルレイヤーを追加する必要がある。

変数の割当に関しては、透かしの一部のbitを改ざんするためにローカル変数のオフセット(この場合`-20`/`-24`)を相互に交換するのは簡単な作業に思える。
しかし、(この例には存在しないが)変数のアドレスが必要になるときもある。

この場合、オフセットは通常の定数(ARMの場合には符号なし整数)として使用され、他の定数からこのオフセットを求めるにはより複雑な解析が必要になる。

実際、攻撃を実装するには、単なる逆アセンブラではなく一種の逆コンパイラが必要になる。
しかし、透かしを改ざんするために逆コンパイルを行うという要求は最高の安全性をもたらすことは明らかである。
