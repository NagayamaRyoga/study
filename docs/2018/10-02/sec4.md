# IV. Problems and future reserch

これまでに取り上げなかった主な問題は、コンパイラによってコードの最適化である。

ソースコードの変更は最適化される可能性がある。
II節で述べた方法は、最適化が切られているときのみちゃんと動く。

最適化が有効な場合、透かし`00`/`11`に対応するコードはそれぞれGCCによって、

```
add r3, r0, #1
sub r0, r0, #1
add r3, r3, r0, asl #1
mov r0, r3
```

と

```
sub r3, r0, #1
add r0, r0, #1
add r0, r0, r3, asl #1
```

にコンパイルされる。

ここでの違いは、文の順序によってのみ決定され、変数宣言の順序には依存しない。
(GCCは最初に使われる変数へr3を割り当てる。)

最適化のいい影響は、文の並び替えがコードレイアウトの変更だけでなく、コードの長さの変更にもつながったことである。
結果として、以降のすべてのコードがメモリ内でシフトされプログラム内の様々な部分に変化を与えるため、電子透かしの埋め込み位置を隠す効果が得られる。

最適化の無効化によって性能の影響が問題になる場合、プログラムの重要な部分を含むソースファイルを透かしの埋め込み対象から外す。
その場合、そうしたファイルは最適化を有効にしてコンパイルできる。

より挑戦的なアプローチは、コンパイラのコード生成を書き換えることである。

実際には、従来のコンパイラは多くの等値な出力コードの選択肢のうち、決定論的に1つの出力コードのみを選択する。

透かしの挿入を実装する最良の方法は、おそらく埋め込まれる透かしに基づいて出力コードを変更するようなコード生成器を作成することである。
