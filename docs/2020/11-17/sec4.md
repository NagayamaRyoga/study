# 4. The Analysis of CRSW

本節ではCRSWのロバスト性とパフォーマンスの低下について論じる。

\(W\)、\(C_m\)、\(C_a\) および \(C_d\) の長さをそれぞれ \(n\) byte、 \(l_m\) byte、\(l_a\) byte、\(l_d\) byteとする。

#### ロバスト性

まず、ロバスト性について考える。

\(R\[[P\]]\) をプログラム \(P\) のセマンティクス、\(\omega \in \Gamma_b = \{\phi \| R\[[\phi(P)\]]\} = R\[[P\]]\) を意味保存変換とする。
CRSWの場合、可視化出力 \(V_\widetilde{W}\) のため、\(R\[[V_\widetilde{W}\]] \subseteq R\[[P'\]]\) が保たれる。
また、意味保存変換の定義に従って以下の関係が成り立つ。

\[
    R\[[V_{\widetilde{W}}\]] \subseteq R\[[P'\]]= R\[[\omega(P)\]] \tag{6}
\]

<!-- textlint-disable -->
式(6) は、意味保存変換は \(V_{\widetilde{W}}\) のセマンティクスを破壊できず、また、CRSWは \(R\[[V_{\widetilde{W}}\]]\) と \(R\[[P\]]\) を区別できるような攻撃を除けば意味保存変換に対して \(V_{\widetilde{W}}\) が耐性を持つことを意味する。
<!-- textlint-enable -->

アンチリバースエンジニアリングモジュールでは、リバースエンジニアリング攻撃を阻止するため、アンチ静的解析手法とアンチ動的デバッグ手法を用いる。
リバースエンジニアリングに対する耐性の評価は、CRSWで用いるアンチリバースエンジニアリング手法に依存する。
さらに、透かしはカオス分散符号化によってプログラムのコードに埋め込まれる。
そのため、命令とデータを組み合わせることによって静的解析への解析をより困難にできる。

カオス分散符号化を用いているため、敵対者がコードの任意の部分のみを再利用しようとすると、透かしがプログラムを失敗させてしまう。
\(W'\) は \(C_m\)、\(C_d\) および \(C_a\) によって置き換えられたコードを除く、全体に均一に分散されるため、平均して \(\frac{l-l_m-l_d-l_a}{n}\) バイトのコードあたり1バイトの透かしが含まれている。
そのため、再利用可能なコードの平均長 \(l_v\) は

\[
    l_v = \frac{l-l_m-l_d-l_a}{n} \tag{7}
\]

となる。

\(l_v \le l_T\) が保証されている場合、透かしのサイズ \(n\) は不等式 \(n \ge \left\lfloor \frac{l - l_m - l_d - l_a}{l_T} \right\rfloor\) を満たさなければならない。

<!-- textlint-disable -->
\(W'\) の位置はカオスシーケンスによって生成されるため、透かしを見つけるのは困難である。
さらに \(s = \partial(i,c,G)\) (カオス置換) は、\(i\) が \(G\) および \(i\) で暗号化されているとみなせる。
\(c\) が改ざんされている場合、\(i = \partial^{-1}(s,c,G)\) を正しくデコードできない。
CRSWの場合、\(W'\) が改ざんされていると、抽出手順で \(W'\) に置き換えられたコードを正しく復元できない。
また、\(C_m\)、\(C_a\) および \(C_d\) が改ざんされている場合、それぞれに置き換えられたコードを復元できず、プログラムの実行が失敗する可能性がある。
与えられた \(G\) に関して、\(c\) は秘密鍵とみなされるため、鍵空間は\(2^{l_c}\) でなければならない (\(l_c\) は \(c\) のサイズ)。
CRSWの鍵空間は \(2^{8(n+l_m+l_d+l_a)}\) である。
<!-- textlint-enable -->

#### パフォーマンス

以下では透かし入りプログラムのパフォーマンス低下について分析する。

容量の観点では、透かしの埋め込みによってプログラムのサイズが大きくなる。
埋め込み処理の際に、アルゴリズムで用いているカオス置換によってプログラムのサイズは \(n+l_m+l_d+l_a\) 増加する。

<!-- textlint-disable -->
実行の観点では、埋め込みによってプログラムの実行時間が増加する。
なぜならば、透かしを埋め込んだプログラムは実行される前に、元のコードを \(S_m\)、\(S_d\)、\(S_a\) および \(S_W\) から復元しなければならないためである。
復元にかかる時間はデジタルカオスシステムの反復効率のみでなく、\(W'\)、\(C_m\)、\(C_a\) および \(C_d\) の内容にも依存する。
1回の反復処理にかかる時間を \(t\) とするとき、\(S_m\)、\(S_d\)、\(S_a\) からコードを復元する時間 \(T_1\) は以下の不等式を満たす。
<!-- textlint-enable -->

\[
    (l_m+l_d+l_a)t \le T_1 \le \frac{1}{\lambda}(l_m+l_d+l_a)t \times 2^8
\]

\(S_W\) からコードを復元する際、まず \(\xi^{-1}\) で用いられる \(n\) byteのカオスシーケンスを生成する必要がある。
したがって、\(S_W\) からコードを復元する時間 \(T_2\) は次を満たす。

\[
    nt + nt \le T_2 \le nt + \frac{2^8}{\lambda}nt
\]

すべてのコードを復元するのにかかる時間 \(T_1 + T_2\) は、

\[
    2nt + (l_m+l_d+l_a)t \le T_1+T_2 \le nt + \frac{2^8}{\lambda}(n+l_m+l_d+l_a)t
\]

を満たす。

\(W'\)、\(C_m\)、\(C_a\)、\(C_d\) が bit-balance (0/1 が同頻度で出現) である場合、処理の平均時間は以下になる。

\[
    \bar{T} = nt + \frac{2^7+0.5}{\lambda}(n+l_m+l_d+l_a)t \tag{11}
\]

通常 \(C_m\)、\(C_a\) および \(C_d\) は固定長、つまり \(l_m+l_d+l_a\) は定数であり、また \(t\) も与えられたデジタルカオスシステムについて定数である。
そのため、式(11) は定数 \(\beta_1\)、\(\beta_2\) を用いて、

\[
    \bar{T} = nt(1+\frac{2^7+0.5}{\lambda})+\frac{2^7+0.5}{\lambda}(l_m+l_d+l_a)t = \beta_1 n+\beta_2 \tag{12}
\]

と表せる。

<!-- textlint-disable -->
式(7) より、 \(n\) が大きく \(l_a\) が小さいほどコードに対する保護が強まることがわかる。
また、式(12) は \(\bar{T}\) が \(n\) に対して線形に増加することを示している。
よって、コード保護の強度とパフォーマンスの低下の間にはトレードオフがある。
<!-- textlint-enable -->
