# 5. Implementation of CRSW

CRSWのアルゴリズムをIntel i386アーキテクチャ上のWindowsオペレーティングシステムを対象として実装した。
本設では入力監視モジュール、アンチリバースエンジニアリングモジュールおよび透かし復号モジュールについて詳説する。
これらのモジュールの実装にはいくつか問題が発生するが、その解決方法についても解説する。


## 5.1. Input Monitoring Module \(C_m\)

\(C_m\) の目的はプログラムの入力を監視することである。
\(C_m\) を実装するにあたって、活性化鍵 \(K_1\) (もしくは一方向関数 \(\mu\) を用いて \(\mu(K_1)\)) をモジュールに含める。
入力 \(\alpha\) が \(K_1\) (もしくは \(\mu(K_1)\)) に一致した場合、透かし復号モジュールが起動される。


## 5.2. Anti-reverse Engineering Module \(C_a\)

理論的には、十分に優れた攻撃者はリバースエンジニアリングによってあらゆるソフトウェアを徹底的に解析でき、リバースエンジニアリングを完全に防ぐことは不可能である。
したがって、このモジュールの目的は時間、労力、またはリソースについて「十分に高コスト」な透かし技術を設計することである。
リバースエンジニアリング手法には静的分析と動的デバッグの2種がある。
そのため、\(C_a\) はアンチ静的解析モジュールとアンチ動的デバッグモジュールの両方から構成される。

#### 静的解析

<!-- textlint-disable -->
デコンパイルは静的解析手法の基礎である。
データと命令が分離されているという仮説に基づいて開発された逆コンパイラを妨害することにより、静的解析を無効化できる。
しかし、フォン・ノイマンアーキテクチャにおいてデータと命令は区別できない。
そのため、命令の間に特別なデータと命令 (これらを妨害データと呼ぶ) を追加することでデータと命令を混在させ、逆コンパイラを妨害できる。
図3の (a) はアセンブリ言語のソースコードを示している。
この1, 5, 6行目は元の命令であり、一方で2, 3, 4行目は妨害データである。
(b) はデコンパイルされた命令列である。
4行目以降でエラーが発生している。
<!-- textlint-enable -->


```asm
(a)
1        xor eax,eax
2        jnz Next
3        jz  Next
4        db  0e8h
5  Next: xor ebx,1
6        add ebx,2

(b)
.text:004010D7  xor eax,eax
.text:004010D9  jnz short near ptr loc_4010DD+1
.text:004010DB  jz  short near ptr loc_4010DD+1
.text:004010DD  call near ptr 83420465h
.text:004010E2  retn
```

**図3: 妨害データの例**

[4]では多くの妨害データが示されている。

本論文では \(C_m\)、\(C_a\)、\(C_d\) に対して複数の妨害データを挿入する。
アンチ静的解析モジュールのコードに暗号化、圧縮、その他を用いることで耐性はさらに増す。

#### 動的デバッグ

動的デバッグはデバッグツールに大きく依存しているため、アンチウイルスの一般原則を導入してプログラムがデバッグツールの特性によってデバッグされているかどうかを検出できる。
デバッグされている場合、プログラムはデバッグを防ぐため間違った制御フローにジャンプする。
SoftICE、Windbg、Ollydbgの特性に基づいたアルゴリズムがすでに実現されている。
実験によってこれらのデバッグツールに抵抗できることを証明している。
他のデバッグツールの特徴を導入することで実装をさらに改善できる。

i386アーキテクチャのプロセッサにはデバッグ用のレジスタがいくつか存在する。
いくつかのデバッグツールはデバッグレジスタを用いてBPM1、ハードウェアブレークポイントなどの機能を実現している[4]。
本論文では、デバッグレジスタの値を変更することでこれらの機能を無効化する。
さらに time sensitive code とブレークポイント検出を導入している。

CRSWdふぇはいくつかの手法を用いてアンチリバースエンジニアリングモジュールを構成している。
このモジュールはスケーラブルであるため、より効率的なリバースエンジニアリング手法を導入することで、よりリバースエンジニアリング攻撃への耐性を強化できる。


## 5.3. Watermark Decoding Module \(C_b\)

透かし復号モジュールは透かし出力モジュールとカオス系モジュールを含んでいる。
透かし出力モジュールは抽出された透かしを視覚的な出力に変換する。
カオス系モジュールは抽出手順のみに用いられるデジタルカオス系を実装する。
カオス系を有限の精度で離散的に実現しようとすると、動的劣化やサイクル帳の短さ、非理想的な分布などの問題が発生する。
また、カオス系の動的劣化を補償する必要がある。
1次元区分線形カオス写像と[11]の劣化補償スキームを適用した。


## 5.4. Problems and Solutions

透かしを実行可能コードに直接埋め込むため、\(C_m\)、\(C_a\)、\(C_d\) を実装すると次の2つの問題が発生する。

1. すべてのモジュールが様々な実行可能コードに埋め込まれたあと、コードとデータがメモリ上の異なるアドレスにロードされるため、コードはメモリ内のデータに正しくアクセスできない。そのため、自己位置特定 (メモリアドレスをコード自身が配置すること) を行う必要がある。

2. 埋め込み後に再コンパイルする必要がないため、モジュールはコンパイラとローダによってWindows APIのアドレスを自動的に見つけられないが、モジュール自身がアドレスを取得しなければならない。

コードとデータの自己位置特定は、`call`/`pop`/`sub`命令によって実装できる。
図4にコードを示す。
レジスタEBXはロードアドレスとデザインアドレスの差を保存するために用いられている。
ロードアドレスはEBXとデザインアドレスの和であり、自己位置である。

```asm
      CALL LAB
LAB:  POP  EBX
      SUB  EBX,OFFSET LAB
```

**図4: 自己位置特定のコード**

Windows APIのアドレスは以下の処理で得られる。

1. 読み込まれたkernel32.dllのベースアドレスを取得する。Windowsには構造化例外処理 (SHE: Structured Exception Handling) という例外処理がある。
    すべての例外処理関数は連結リストに保存されており、その最後の要素はkernel32.dllのモジュールにあるデフォルト例外処理関数である。
    連結リストを操作することで、デフォルト例外処理関数のアドレスを取得でき、そこからkernel32.dllのベースアドレスを特定できる。

2. Windows APIの`LoadLibrary`と`GetProcAddress`のアドレスをkernel32.dllのエクスポートテーブルから取得する。

3. 任意のWindows APIのアドレスを`LoadLibrary`と`GetProcAddress`を用いて取得する。
