# 2. Exception Handling Dynamic Watermarking Algorithm

## 2.1. Algorithm Framework

提案アルゴリズムは透かしの構築、埋め込み、そして抽出からなる。
アルゴリズムの概要を図1に示す。

![](fig1.png)

**図1: アルゴリズムの概要**

埋め込まれる透かしは、元の透かし \(W\) を、与えられた例外型の集合 \(E\) と透かし生成鍵 \(Kg\) を用いて例外型の列のとして符号化することで生成される。
埋め込み鍵 (プログラムに対する秘密の入力) を用いて、ターゲットプログラム \(P\) のソースコードに例外処理シーケンスを挿入することで透かしが埋め込まれる。
透かしはプログラムの実行中に直接抽出される。
抽出鍵を用いてプログラムを実行し、トリガーされた例外を監視することで埋め込まれた例外型の列を取得する。
次に、透かし生成鍵 \(Kg\) を用いて透かし \(W'\) を復元する。


## 2.2. Watermark Generation

透かし \(W\) を \(l\) bitのバイナリ列、与えられた例外型の集合 \(E=\{e_0,e_1,\dots,e_{n-1}\}\) とする。
透かし生成プロセスの目的は、透かし \(W\) を、生成鍵 \(Kg\) を用いて例外型の列 \(E^W=(e^W_0,e^W_1,\dots,e^W_{s-1})\) に符号化することである。

\(e^W_i \in E \quad (i=0,1,\dots,s-1)\) および \(n=2^m\) は、集合 \(E\) の各例外型が \(m\) bitの透かし片を表せることを示している。
\(s=\left\lceil \frac{l}{m} \right\rceil\) は透かし片の数である。
詳細を以下に示す。

<!-- textlint-disable -->
1. 透かし \(W\) (\(l\) bit) を長さ \(m\) で、\(s=\left\lceil \frac{l}{m} \right\rceil\) 個の透かし片に分割することで \(\widetilde{W}=(\tilde{w}_0,\tilde{w}_1,\dots,\tilde{w}_{s-1})\) を得る。\(l\) が \(m\) の倍数でない場合、末尾に \(0\) を付与する。

2. 例外型の集合 \(E=\{e_0,e_1,\dots,e_{n-1}\}\) を鍵 \(Kg\) でシャッフルし、列 \(\widetilde{E}=(\tilde{e}_0,\tilde{e}_1,\dots,\tilde{e}_{n-1}) \; (\tilde{e}_i \in E, \forall i \ne j \; (i,j=0,1, \dots,n-1), \; \tilde{e}_i \ne \tilde{e}_j)\)を得る。

3. 例外型の列 \(E^W=(e^W_0,e^W_1,\dots,e^W_{s-1})\) を \(\widetilde{W}=(\tilde{w}_0,\tilde{w}_1,\dots,\tilde{w}_{s-1})\) (ただし整数 \(i=0,1,\dots,s-1\) について \(\tilde{w}_i \in [0,2^{m-1}]\)) から \(e^W_i=\tilde{e}_{\tilde{w}_i}\) となるように生成する。
<!-- textlint-enable -->

## 2.3. Watermark Embedding

\(P\) を元のプログラムとする。
受け入れ可能な入力 \(\Omega = (I_0,I_1,\dots,I_{r-1})\) を透かしの埋め込み鍵として選び、例外型の列 \(E^W\) を \(P\) に埋め込み、透かし入りプログラム \(P'\) を得る。
詳細な手順を以下に示す。

<!-- textlint-disable -->
1. プログラム \(P\) をデバッグモードで実行し、\(\Omega\) の各入力 \(I_i \; (i=0,1,\dots,r-1)\) に対応する実行パス \(T=\{t_0,t_1,\dots,t_{r-1}\}\) を得る。

2. \(T\) の各実行シーケンス \(t_i\) についてすべての変数を出力し、集合 \(S_i=\{s_{i,0},s_{i,1},\dots,s_{i,h_i-1}\}\) とその型 \(V^{S_i}=\{v^{S_i}_0,v^{S_i}_1,\dots,v^{S_i}_{h_i-1}\}\) を得る。

3. 例外型の列 \(E^W=(e^W_0,e^W_1,\dots,e^W_{s-1})\) を \(r\) 個のグループ \(E^W_0,E^W_1,\dots,E^W_{r-1}\) に分割する。各 \(E^W_i = (e^W_{i,0},e^W_{i,1},\dots,e^W_{i,u_i-1})\) について \(u_i \le h_i\) かつ \(\sum_{i=1}^r u_i=s\) である。

4. \(i\) 番目の例外型の列 \(E^W_i = (e^W_{i,0},e^W_{i,1},\dots,e^W_{i,u_i-1})\) を、対応する \(t_i\) の変数列 \(S_i\) に、以下の手順で埋め込む。
<!-- textlint-enable -->

    - 埋め込み点を選択する。

    - \(E^W_i\) の各例外型 \(e^W_i{i,j}\) について、型が \(V_{\Phi_{i,j}}\) であるトリガー条件 \(\Phi_{i,j}\) を設定する。

    - 変数 \(s_{i,k} \in S_i\) が存在し、その型 \(v^{S_i}_k\) が要求される変数の型 \(V_{\Phi_{i,j}}\) に似通っているならば、\(s_{i,k}\) を例外型 \(e^W_{i,j}\) の埋め込み点として用いる。そうでなければ、列 \(S_i\) からランダムな変数 \(s_{i,q}\) を選択し、\(s_{i,q}\) を用いた演算から型 \(V_{\Phi_{i,j}}\) であるような新たな変数 \(s'\) を生成し埋め込み点として用いる。

    - 埋め込み点に例外型を埋め込む。簡単のために埋め込み点を \(\tilde{s}\) を表記する。
        例外型 \(e^W{i,j}\) の添字 \(i, j\) とマジックナンバー \(R\) に従い、式(1)を用いて例外処理に埋め込まれる識別子 \(f\) を生成する。
        また、抽出の際に例外型のシリアル番号をマークする。

\[
    f = En_{key}(R,i,j) \tag{1}
\]

\(e^W_{i,j}\) の埋め込み処理の擬似コードを以下に示す。

---
<!-- textlint-disable -->
_try {<br>
　　\(\Phi_{i,j}(\overline{s})\);　// \(\Phi_{i,j}(\overline{s})\) は変数 \(\overline{s}\) から生成された、例外型 \(e^W_{i.j}\) をトリガーするコード<br>
}<br>
_except {<br>
　　If (predicates(\(f\)))　// predicates(\(f\)) は定数 \(f\) を含むコード<br>
　　{<br>
　　　　\(\overline{s} = \Phi^{-1}_{i,j}\);　// \(\Phi^{-1}_{i,j}\) は例外処理コード、\(\overline{s}\) の値を元にもどす<br>
　　}<br>
}

注: Predicates(\(f\)) は生成した埋め込み識別子 \(f\) を用いて設計される。
\(f\) が式(1)で計算される場合、Predicates(\(f\)) の値は`true`になり例外処理のコードが実行される。このときの元のプログラムの変数 \(\overline{s}\) の値が復元される。
そうしなければ、\(\Phi^{-1}_{i,j}\) は正しく実行できず、プログラムが正しく実行されない。
<!-- textlint-enable -->
---

TODO


## 2.4. Watermark Extraction

TODO
