# 5 Implementation Details

我々のGA1とGA2の実装はArboitによって提案されたアルゴリズム[5]に従っている。
攻撃への耐性を高めるため、以下で述べるいくつかの変更を加えた。
さらに、動的なバージョンのアルゴリズムを開発した。


## 5.1 Watermark Encoding

Arboitは電子透かしの各部分がインデックス値も含むような符号化技術を提案した。
インデックス値を含めることによって、透かしの断片が任意の順序で復元できるようになる。
我々の実装も任意の順序で復元できるが、インデックス値を必要としない。
整数として符号化された透かし \(w\) を、\(0 \le w_i \le n\) であるような \(k\) 個の断片 \(\{w_1, w_2, \dots, w_k\}\) に分割する。
透かしの分割に用いる技術は、\(m\) 要素の多重集合 \(S\) (ただし \(S = \{s_i : 0 \le s_i \le n\}\)) と \(m + n\) 個の要素から選択されたサイズ \(n\) の組み合わせとの間の1対1対応に依存している。
この対応関係が与えられると、分割機構はいくつかの固定の \(n\) について、\(m + n\) 要素から選ばれた \(n\) の組み合わせを列挙する。
この分割手法によって、各透かしの断片の順序は重要でなくなる。

透かしの以下の方法のうち一方を用いて不明瞭な述語に埋め込まれる。

1. 述語の定数を利用する
2. 既知の不明瞭な述語のそれぞれに値を割り当てる

述語が数論的なものであるなら、\(w_i\) はそれぞれ以下のような方法で符号化される。

1. 述語内の定数
2. 新しい定数の挿入

例として、値 \(42\) を述語 \(4 \| x^2(x+1)(x+1)\) を用いて符号化することを考える。
この述語は3つの定数 \(4, 1, 1\) を含むため、\(6\) の値を表現している。
そのため、加えて (\(42 - 6 =\)) \(36\) の値を符号化する必要がある。
このとき両辺に \(18\) を掛けることで述語 \((18)(4) \| (18)x^2(x+1)(x+1)\) が得られる。
この手法は述語の評価値を変化させることなく任意の \(m \in \N\) をエンコードできる。
奇数の値を符号化する場合は、\(2 \| x(x + 1)\) などのように奇数の述語を選択する。

<!-- textlint-disable japanese/no-doubled-joshi -->
<!-- textlint-disable ja-technical-writing/max-comma -->
定数を使用して透かしを符号化する技術は有効ではあるが、述語に含まれる定数のみを使用することは制限されている。
例えば、表1の9つの述語は、\(\{0, 3, 4, 6, 8, 27, 88\}\) の値しか符号化できない。
新しい定数を挿入することの欠点は、不明瞭な述語がより明白になってしまうことである。

位数を使用して \(w_i\) を符号化するには、それぞれの不明瞭な述語に、0 から始まる値を割り当てる。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>で用いている既知の述語は \(\{0, \dots, 8\}\) の値に符号化できる。
この手法は単純ではあるが、実用のためには不明瞭な述語のライブラリが適切なサイズでなければならない。
<!-- textlint-enable -->


## 5.2 Watermark Embedding

埋め込みプロセスは、埋め込み可能な分岐点の集合 \(B\) の識別に依存している。
この集合は、アプリケーションの各メソッドを前処理することで識別される。
各 \(w_i \in w\) に対して、不明瞭な述語 \(P_{b_j}^T\) または不明瞭なメソッド \(M_{b_j}^T\) の呼び出した選択された分岐点 \(b_j \in B\) に挿入される。
アルゴリズムの強度を高めるために、不明瞭な述語で使用できるメソッドのローカル変数を特定する。
これらの変数は \(b_j\) を中心とした *前方スライス (forward slice)* [20] を用いて識別される。

不明瞭な述語に変数を使用することのもっとも大きな利点は、(新しい変数を挿入することとは対照的に) 述語の性質を隠蔽するのに役立つことである。
この手法の現状の欠点は、選択された \(b_j\) の周りに整数を含むローカル変数を見つけ出せるとは限らないことである。
そのため、いくつかの分岐点は利用できない。
この欠点は、他のタイプの不明瞭な述語が使用できれば軽減できる。

また、ステルス性を高めるだけでなく、オーバヘッドを減らすため実装に手を加えた。
GA2を用いて透かしを埋め込むために、アプリケーションに新しいメソッドを追加する。
これによるコードサイズの増加は、モバイルデバイスのようなサイズ制限の厳しいアプリケーションには不向きかもしれない。
解決策の1つは、位数を用いて \(w_i\) を符号化し、アプリケーションに追加された新しいメソッドを再利用することである。
例えば、クラス `C` のメソッドを再利用しなかった場合、`C` は図1のように変換される。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if ((a + b) <= c) {...}
        else {...}
        ...
    }
}
    ↓
class C {
    void m1(int a, int b) {
        ...
        if ((a <= b) && m3()) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if (((a + b) <= c) && m4()) {...}
        else {...}
        ...
    }
    boolean m3() {
        int c = 1;
        return (c * c <= 0);
    }
    boolean m4() {
        int c = 1;
        return (c * c <= 0);
    }
}
```

**図1: メソッドを再利用しない変換**

メソッドを再利用する場合は図2のようになる。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if ((a + b) <= c) {...}
        else {...}
        ...
    }
}
    ↓
class C {
    void m1(int a, int b) {
        ...
        if ((a <= b) && m3()) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if (((a + b) <= c) && m3()) {...}
        else {...}
        ...
    }
    boolean m3() {
        int c = 1;
        return (c * c <= 0);
    }
}
```

**図2: メソッドを再利用する変換**

さらに不明瞭なメソッドを偽装することでステルス性を高めている。

<!-- textlint-disable japanese/no-doubled-joshi -->
Arboitはメソッドのオーバーロードを用いて、攻撃者による透かしの破壊を防ぐ技術について述べている。
もし攻撃者がオーバーロードされたメソッドの方を変更しようとすると、オーバーライドが発生し動作に問題が生じる可能性がある。
現在の実装ではこの技術をサポートしていないが、GA1がGA2よりも優れている場合には、このような技術では透かしを破壊を防げないことをSection 6で示す。
<!-- textlint-enable -->


## 5.3 Watermark Recognition

どの埋め込み技術を用いるかによって、透かしの認識手順は少し異なる。
GA1を用いた電子透かしの復元は、各メソッドの網羅的な探索を必要とする。
不明瞭な述語の可能性のある命令セットを識別するために、制御フローグラフ (CFG) [4] の基本ブロックと式木が構築される。
各不明瞭な述語は基本ブロックの最後の命令である `if` 命令で終了している。
その`if`命令の式木を構成する命令は、不明瞭な述語のライブラリと比較される。

<!-- textlint-disable japanese/no-doubled-conjunction -->
透かしがGA2を用いて埋め込まれている場合、不明瞭なメソッドと同じシグネチャを持つメソッドの`invoke`命令を探索する・
現在の実装では、すべての不明瞭なメソッドは`boolean`型の返り値と`int`型の1つまたは2つの引数を持つ。
不明瞭なメソッドが再利用されない場合、認識手順は各メソッドのシグネチャをチェックするだけに簡素化される。
しかしメソッドが再利用される場合は、これだけでは正しい透かし分割数が得られない。
各不明瞭なメソッドにはGA1と同じ方法で識別される不明瞭な述語が含まれている。
\(w_i\) が位数を用いて符号化されている場合、その述語の位数が識別される。
定数が使用されている場合、定数の合計値が述語から抽出される。
すべての \(w_i\) が識別されると、透かしの値を復元するために結合される。
<!-- textlint-enable -->
