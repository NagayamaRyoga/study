# 5 Implementation Details

我々のGA1とGA2の実装はArboitによって提案されたアルゴリズム[5]に従っている。
攻撃への耐性を高めるため、以下で述べるいくつかの変更を加えた。
さらに、動的なバージョンのアルゴリズムを開発した。


## 5.1 Watermark Encoding

Arboitは電子透かしの各部分がインデックス値も含むような符号化技術を提案した。
インデックス値を含めることによって、透かしの断片が任意の順序で復元できるようになる。
我々の実装も任意の順序で復元できるが、インデックス値を必要としない。
整数として符号化された透かし \(w\) を、\(0 \le w_i \le n\) であるような \(k\) 個の断片 \(\{w_1, w_2, \dots, w_k\}\) に分割する。
透かしの分割に用いる技術は、\(m\) 要素の多重集合 \(S\) (ただし \(S = \{s_i : 0 \le s_i \le n\}\)) と \(m + n\) 個の要素から選択されたサイズ \(n\) の組み合わせとの間の1対1対応に依存している。
この対応関係が与えられると、分割機構はいくつかの固定の \(n\) について、\(m + n\) 要素から選ばれた \(n\) の組み合わせを列挙する。
この分割手法によって、各透かしの断片の順序は重要でなくなる。

透かしの以下の方法のうち一方を用いて不明瞭な述語に埋め込まれる。

1. 述語の定数を利用する
2. 既知の不明瞭な述語のそれぞれに値を割り当てる

述語が数論的なものであるなら、\(w_i\) はそれぞれ以下のような方法で符号化される。

1. 述語内の定数
2. 新しい定数の挿入

例として、値 \(42\) を述語 \(4 \| x^2(x+1)(x+1)\) を用いて符号化することを考える。
この述語は3つの定数 \(4, 1, 1\) を含むため、\(6\) の値を表現している。
そのため、加えて (\(42 - 6 =\)) \(36\) の値を符号化する必要がある。
このとき両辺に \(18\) を掛けることで述語 \((18)(4) \| (18)x^2(x+1)(x+1)\) が得られる。
この手法は述語の評価値を変化させることなく任意の \(m \in \N\) をエンコードできる。
奇数の値を符号化する場合は、\(2 \| x(x + 1)\) などのように奇数の述語を選択する。

<!-- textlint-disable japanese/no-doubled-joshi -->
<!-- textlint-disable ja-technical-writing/max-comma -->
定数を使用して透かしを符号化する技術は有効ではあるが、述語に含まれる定数のみを使用することは制限されている。
例えば、表1の9つの述語は、\(\{0, 3, 4, 6, 8, 27, 88\}\) の値しか符号化できない。
新しい定数を挿入することの欠点は、不明瞭な述語がより明白になってしまうことである。

位数を使用して \(w_i\) を符号化するには、それぞれの不明瞭な述語に、0 から始まる値を割り当てる。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>で用いている既知の述語は \(\{0, \dots, 8\}\) の値に符号化できる。
この手法は単純ではあるが、実用のためには不明瞭な述語のライブラリが適切なサイズでなければならない。
<!-- textlint-enable -->


## 5.2 Watermark Embedding

埋め込みプロセスは、埋め込み可能な分岐点の集合 \(B\) の識別に依存している。
この集合は、アプリケーションの各メソッドを前処理することで識別される。
各 \(w_i \in w\) に対して、不明瞭な述語 \(P_{b_j}^T\) または不明瞭なメソッド \(M_{b_j}^T\) の呼び出した選択された分岐点 \(b_j \in B\) に挿入される。
アルゴリズムの強度を高めるために、不明瞭な述語で使用できるメソッドのローカル変数を特定する。
これらの変数は \(b_j\) を中心とした *前方スライス (forward slice)* [20] を用いて識別される。

不明瞭な述語に変数を使用することのもっとも大きな利点は、(新しい変数を挿入することとは対照的に) 述語の性質を隠蔽するのに役立つことである。
この手法の現状の欠点は、選択された \(b_j\) の周りに整数を含むローカル変数を見つけ出せるとは限らないことである。
そのため、いくつかの分岐点は利用できない。
この欠点は、他のタイプの不明瞭な述語が使用できれば軽減できる。

また、ステルス性を高めるだけでなく、オーバヘッドを減らすため実装に手を加えた。
GA2を用いて透かしを埋め込むために、アプリケーションに新しいメソッドを追加する。
これによるコードサイズの増加は、モバイルデバイスのようなサイズ制限の厳しいアプリケーションには不向きかもしれない。
解決策の1つは、位数を用いて \(w_i\) を符号化し、アプリケーションに追加された新しいメソッドを再利用することである。
例えば、クラス `C` のメソッドを再利用しなかった場合、`C` は図1のように変換される。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if ((a + b) <= c) {...}
        else {...}
        ...
    }
}
    ↓
class C {
    void m1(int a, int b) {
        ...
        if ((a <= b) && m3()) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if (((a + b) <= c) && m4()) {...}
        else {...}
        ...
    }
    boolean m3() {
        int c = 1;
        return (c * c <= 0);
    }
    boolean m4() {
        int c = 1;
        return (c * c <= 0);
    }
}
```

**図1: メソッドを再利用しない変換**

メソッドを再利用する場合は図2のようになる。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if ((a + b) <= c) {...}
        else {...}
        ...
    }
}
    ↓
class C {
    void m1(int a, int b) {
        ...
        if ((a <= b) && m3()) {...}
        else {...}
        ...
    }
    void m2(int a, int b, int c) {
        ...
        if (((a + b) <= c) && m3()) {...}
        else {...}
        ...
    }
    boolean m3() {
        int c = 1;
        return (c * c <= 0);
    }
}
```

**図2: メソッドを再利用する変換**

さらに不明瞭なメソッドを偽装することでステルス性を高めている。

<!-- textlint-disable japanese/no-doubled-joshi -->
Arboitはメソッドのオーバーロードを用いて、攻撃者による透かしの破壊を防ぐ技術について述べている。
もし攻撃者がオーバーロードされたメソッドの方を変更しようとすると、オーバーライドが発生し動作に問題が生じる可能性がある。
現在の実装ではこの技術をサポートしていないが、GA1がGA2よりも優れている場合には、このような技術では透かしを破壊を防げないことをSection 6で示す。
<!-- textlint-enable -->


## 5.3 Watermark Recognition

どの埋め込み技術を用いるかによって、透かしの認識手順は少し異なる。
GA1を用いた電子透かしの復元は、各メソッドの網羅的な探索を必要とする。
不明瞭な述語の可能性のある命令セットを識別するために、制御フローグラフ (CFG) [4] の基本ブロックと式木が構築される。
各不明瞭な述語は基本ブロックの最後の命令である `if` 命令で終了している。
その`if`命令の式木を構成する命令は、不明瞭な述語のライブラリと比較される。

<!-- textlint-disable japanese/no-doubled-conjunction -->
透かしがGA2を用いて埋め込まれている場合、不明瞭なメソッドと同じシグネチャを持つメソッドの`invoke`命令を探索する・
現在の実装では、すべての不明瞭なメソッドは`boolean`型の返り値と`int`型の1つまたは2つの引数を持つ。
不明瞭なメソッドが再利用されない場合、認識手順は各メソッドのシグネチャをチェックするだけに簡素化される。
しかしメソッドが再利用される場合は、これだけでは正しい透かし分割数が得られない。
各不明瞭なメソッドにはGA1と同じ方法で識別される不明瞭な述語が含まれている。
\(w_i\) が位数を用いて符号化されている場合、その述語の位数が識別される。
定数が使用されている場合、定数の合計値が述語から抽出される。
すべての \(w_i\) が識別されると、透かしの値を復元するために結合される。
<!-- textlint-enable -->


## 5.4 Dynamic Arboit Algorithms

動的アルゴリズムが静的アルゴリズムよりも攻撃に強いかどうかは、ソフトウェア透かしの分野における未解決問題の1つである。
その調査の方法の1つは、既知の静的アルゴリズムの動的バージョンを開発、実装し、それを評価することである。
今回、我々はGA1とGA2の動的バージョン (それぞれDGA1、DGA2) を開発し、実装した。

<!-- textlint-disable ja-technical-writing/ja-no-redundant-expression -->
動的アルゴリズムはプログラムの実行状態を利用して、透かしの埋め込みと認識を行う。
3つの動的手法が存在する [7]。
<!-- textlint-enable -->

- イースターエッグ透かし
- データ構造透かし
- 実行トレース透かし

DGA1とDGA2は、特定の入力が与えられたときの実行トレースを用いるため実行トレース透かしアルゴリズムである。
入力はユーザの秘密鍵を表現する。
例えば○×ゲームの場合、×と○の配置順序が秘密鍵になる。

<!-- textlint-disable ja-technical-writing/ja-no-redundant-expression -->
DGA1とDGA2の独特の点は、ランダムに選択された分岐点ではなく、プログラムの分岐点の集合 \(B\) を特定するために実行トレースを使用することである。
攻撃者がアプリケーションをどれだけ歪めても、秘密鍵を使って実行すると、プログラムは元の分岐点の集合を実行する。
この仮定は、実行の分岐点をスキップするような変換はアプリケーションの機能を変化させる可能性が高いという考えに基づいている。
そのため、動的な性質は歪み攻撃へのアルゴリズムの耐性を向上させる。
<!-- textlint-enable -->

プログラムの分岐点 \(B\) は埋め込みフェーズと認識フェーズの双方で必要になる。
\(B\) は追加された注釈とともにコンパイルされる。
注釈付けのフェーズは完全に自動化されており、`if` 命令の直前に特別な関数呼び出しを追加する。
この特別な関数呼び出しはブレークポイントを表している。
アプリケーションの実行中、関数が呼び出されるたびに `if` 命令の位置が記録される。

図3 (a) と図3 (b) は注釈による変換を表している。
埋め込み手順を説明するため、秘密の入力をアプリケーションに与えたときの実行経路が <!-- textlint-disable ja-technical-writing/max-comma -->\(\{1, 2, 4, 9, 10, 11, 13, 14\}\)<!-- textlint-enable --> であったとする。
したがって、集合 \(B\) はブロック `2` と `10` の `if` 命令で構成される。
この手法では、透かしを埋め込むためにGA1またはGA2を用いる。
この例の場合、変換は図3 (c) のようになる

**図3:DGA1やDGA2を用いた透かし手法の注釈付け (元論文を参照)**

<!-- textlint-disable japanese/no-doubled-joshi -->
透かしの挿入されたアプリケーションの実行トレースを得ることで、認識された集合 \(B\) を取得する。
この例では、実行トレースは <!-- textlint-disable ja-technical-writing/max-comma -->\(\{1, 2, 4, 9, 10, 11, 13, 14\}\)<!-- textlint-enable ja-technical-writing/max-comma --> というブロックで構成される。
ブロック2'に挿入された不明瞭な述語が実行されていないことがわかる。
これは、Javaが短絡評価を行うため、2番目の述語は必ずしも評価される必要がないためである。
(現在の実装では、挿入されたすべての述語は真に評価される。)
トレースはブロック2を特定したため、2'の不明瞭な述語を復元できる。
これは、トレースで発見されたすべての `if` 命令のフォールスルーブロックを調べることで復元できるためである。
<!-- textlint-enable -->
