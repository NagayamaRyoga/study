# 5 Implementation Details

我々のGA1とGA2の実装はArboitによって提案されたアルゴリズム[5]に従っている。
攻撃への耐性を高めるため、以下で述べるいくつかの変更を加えた。
さらに、動的なバージョンのアルゴリズムを開発した。


## 5.1 Watermark Encoding

Arboitは電子透かしの各部分がインデックス値も含むような符号化技術を提案した。
インデックス値を含めることによって、透かしの断片が任意の順序で復元できるようになる。
我々の実装も任意の順序で復元できるが、インデックス値を必要としない。
整数として符号化された透かし \(w\) を、\(0 \le w_i \le n\) であるような \(k\) 個の断片 \(\{w_1, w_2, \dots, w_k\}\) に分割する。
透かしの分割に用いる技術は、\(m\) 要素の多重集合 \(S\) (ただし \(S = \{s_i : 0 \le s_i \le n\}\)) と \(m + n\) 個の要素から選択されたサイズ \(n\) の組み合わせとの間の1対1対応に依存している。
この対応関係が与えられると、分割機構はいくつかの固定の \(n\) について、\(m + n\) 要素から選ばれた \(n\) の組み合わせを列挙する。
この分割手法によって、各透かしの断片の順序は重要でなくなる。

透かしの以下の方法のうち一方を用いて不明瞭な述語に埋め込まれる。

1. 述語の定数を利用する
2. 既知の不明瞭な述語のそれぞれに値を割り当てる

述語が数論的なものであるなら、\(w_i\) はそれぞれ以下のような方法で符号化される。

1. 述語内の定数
2. 新しい定数の挿入

例として、値 \(42\) を述語 \(4 \| x^2(x+1)(x+1)\) を用いて符号化することを考える。
この述語は3つの定数 \(4, 1, 1\) を含むため、\(6\) の値を表現している。
そのため、加えて (\(42 - 6 =\)) \(36\) の値を符号化する必要がある。
このとき両辺に \(18\) を掛けることで述語 \((18)(4) \| (18)x^2(x+1)(x+1)\) が得られる。
この手法は述語の評価値を変化させることなく任意の \(m \in \N\) をエンコードできる。
奇数の値を符号化する場合は、\(2 \| x(x + 1)\) などのように奇数の述語を選択する。

<!-- textlint-disable japanese/no-doubled-joshi -->
<!-- textlint-disable ja-technical-writing/max-comma -->
定数を使用して透かしを符号化する技術は有効ではあるが、述語に含まれる定数のみを使用することは制限されている。
例えば、表1の9つの述語は、\(\{0, 3, 4, 6, 8, 27, 88\}\) の値しか符号化できない。
新しい定数を挿入することの欠点は、不明瞭な述語がより明白になってしまうことである。

位数を使用して \(w_i\) を符号化するには、それぞれの不明瞭な述語に、0 から始まる値を割り当てる。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>で用いている既知の述語は \(\{0, \dots, 8\}\) の値に符号化できる。
この手法は単純ではあるが、実用のためには不明瞭な述語のライブラリが適切なサイズでなければならない。
<!-- textlint-enable -->


## 5.2 Watermark Embedding



## 5.3 Watermark Recognition


