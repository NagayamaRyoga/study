# 6 Evaluation

ソフトウェア透かし手法が海賊版ソフトウェアと著作権侵害に対して効果的であるためには、透かしの発見と削除の試みに対して耐性がなければならない。

ソフトウェア透かしシステムの強度の評価に関する研究はほとんど行われていないため、正式な透かしの体制に関する特性は確立されていない。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>システムを用いたソフトウェア透かしアルゴリズムに関する研究を通して、アルゴリズムの評価に役立つと考えられる以下の特性をまとめた [7, 10, 16]:

<dl>
<dt>信頼性 (credibility)</dt>
<dd>認識手順は埋め込まれた透かしを抽出でき、偽の透かしを識別できなくてはならない。</dd>

<dt>データレート(data-rate)</dt>
<dd>アルゴリズムは秘密文を埋め込むために、高いデータ率を持たなくてはならない。</dd>

<dt>オーバヘッド (overhead)</dt>
<dd>透かしの埋め込みがアプリケーションのパフォーマンスにほとんど影響を与えず、埋め込み/認識手順にコストが掛からないことが望ましい。</dd>

<dt>部分の保護 (part protection)</dt>
<dd>透かしを保護するためには埋め込み箇所をアプリケーション全体に分散させる必要がある。</dd>

<dt>頑健性 (resiliency)</dt>
<dd>
透かしは発見や削除の試みに対して頑健でなければならない。特に3つの重要な攻撃に対して耐性を持たなければならない。

- *減算攻撃 (subtractive attack)*: 逆アセンブル・逆コンパイルされたコードから透かしを除去する攻撃
- *加算攻撃 (additive attack)*: 最初に埋め込まれた透かしがどれかわからなくなるように再度透かしを埋め込む攻撃
- *歪曲攻撃 (distortive attack)*: 意味論的に等価な変換を行い、ソフトウェアの機能と性能を維持しつつ透かしを復元不可能にする攻撃
</dd>

<dt>ステルス性 (stealth)</dt>
<dd>埋め込まれた透かしの検出が困難であること。そのためには、透かしの埋め込まれた箇所のコードやデータは、それ以外の箇所と同じ特性を持っていなければならない。</dd>
</dl>

S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>内に実装されたArboitアルゴリズムの静的バージョンと動的バージョンの両方を、上記の各特性について評価した。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>は攻撃者が透かしの発見と削除に用いることのできる様々なツールを含む。
これらのツールには以下のものが含まれる。v

- 歪曲攻撃を受けた場合の透かしの頑健性を評価するための難読化ツール
- 加算攻撃を調べるため (もしくは比較のため) の追加の透かしアルゴリズム
- 透かしの埋め込まれたバイトコードを表示し、透かしのステルス性を手動で調べるためのバイトコードビューア
- ステルス性の評価に用いることのできる、メソッドの数や条件分の数などアプリケーションに関する静的な統計情報を提供する統計モジュール

静的なGA1とGA2を評価するために、サイズと複雑さの異なる11のアプリケーションを用いた。
この11のアプリケーションのうち、○×ゲーム (TTT) とJKeyboard (ソフトウェアキーボード) 2つは動的アルゴリズムにも使用した。
動的アルゴリズムの評価には、異なる実行トレースを得るためにユーザの入力を利用するアプリケーションが必要になる。
10個のアプリケーションの詳細を表2に示す。(11番目のアプリケーションはspacjvmである。)

| アプリケーション | クラス数 | メソッド数 | サイズ [B] |
|:---------------:|--------:|----------:|----------:|
| decode          |       4 |        20 |      2754 |
| fft             |       1 |        10 |       980 |
| illness         |      16 |        37 |       764 |
| lu              |       1 |         7 |       758 |
| machineSim      |      12 |       110 |      6017 |
| matrix          |       2 |        10 |      1054 |
| probe           |       1 |         7 |       836 |
| puzzle          |       3 |        20 |      5995 |
| TTT             |      12 |        51 |      2358 |
| JKeyboard       |      30 |       147 |     32537 |

**表2: GA1とGA2の評価に用いたベンチマークアプリケーション**


## 6.1 Credibility

透かしアルゴリズムの信頼性 (credibility) は透かしの復元精度に基づいている。
アプリケーションに埋め込まれていない透かしを復元したり (偽陽性)、埋め込まれた電子透かしを復元できなかったり (偽陰性) するとアルゴリズムの信頼性は低くなる。
この特性を評価するために、透かしの埋め込まれていないベンチマークアプリケーションや難読化されたものに対して認識アルゴリズムを実行した。
どのケースでも偽陽性や偽陰性は検出されなかった。


## 6.2 Data-rate

<!-- textlint-disable japanese/no-doubled-joshi -->
GA1とGA2、DGA1、DGA2のデータレートはおおよそ同程度になった。
これは、いずれも `if` 命令を識別することに基づいているためである。
一方で、透かしが定数を用いてエンコードされているか、位数を用いてエンコードされているかによってはデータレートが変わる。
位数が用いられている場合、各埋め込み箇所に埋め込める値は0から8に制限されているため、定数を用いるものに比べデータレートは低い。
定数を用いる方法は約7倍の埋め込み空間を確保できることを表3に示す。
この表は、ベンチマークアプリケーション中の `if` 命令の数も示している。
このことから、不明瞭な述語ライブラリを拡張することで埋め込み量が増やせることがわかる。
<!-- textlint-enable -->

| アプリケーション | 定数を用いたときの最大埋め込み文字数 | 位数を用いたときの最大埋め込み文字数 | `if` 命令の数 |
|:---------------:|--------:|----------:|----------:|
| decode          |      21 |         3 |        36 |
| fft             |       7 |         1 |        16 |
| illness         |      18 |         3 |       104 |
| lu              |      13 |         2 |        17 |
| machineSim      |      37 |         4 |       162 |
| matrix          |      18 |         2 |        36 |
| probe           |       8 |         1 |        17 |
| puzzle          |      36 |         5 |       154 |
| TTT             |      25 |         3 |        54 |
| JKeyboard       |      46 |         4 |       147 |

**表3: 定数と位数によってそれぞれ埋め込み可能な情報量**


## 6.3 Overhead

透かしアルゴリズムのオーバヘッド特性を評価する方法には様々なものがある。

1. 透かしがアプリケーションのサイズにどのような影響を与えるか
2. 透かしがパフォーマンスにどのような影響を与えるか
3. 埋め込みと認識にどのくらいのコストがかかるか

サイズの増加は透かしの分割数、つまり埋め込む透かしのサイズに依存する。
さらに、符号化技術もオーバヘッドに影響を与える。
定数値を用いる埋め込み手法の場合、各 \(w_i\) に埋め込める値はより大きくなるため透かしを多くの部分に分割する必要はない。
各 \(w_i\) につき、アプリケーションはおおよそ80バイト大きくなる。
\(w_i\) が位数を用いて符号化されているときは、メソッドを再利用することでオーバヘッドを減らすことができる。

CaffeineMark [18] ベンチマークは、透かしの埋め込みがアプリケーションの実行時間に与える影響を表している。
表4から、透かしの埋め込みが実行時間に与える負の影響がほぼないことを示している。


埋め込みや認識の手順は非常に効率的である。
外規模なアプリケーションであっても、数秒で透かしを挿入できる。
アルゴリズムの中でもっともコストがかかるのは、GA1、GA2の前処理と、DGA1とDGA2の注釈付けである。
分岐点の集合が判明すると、\(k\) 個の不明瞭な述語を埋め込むのに必要な時間は無視できるほど小さい。


## 6.4 Part Protection

部分の保護特性の基本となるアイデアは、透かしを分割してアプリケーション全体に広げることである。
分割された透かしは、攻撃者がアプリケーションの複数の場所を攻撃対象とすることを必要とするため、残る可能性が高くなる。
静的アルゴリズムと動的アルゴリズムのどちらも、透かしを分割しランダムに分散させることで、部分的な保護を組み込んでいる。
不明瞭なメソッドを再利用することで、オーバヘッドを減らしステルス性を高めることができると述べましたが、一方でこの手法は部分の保護特性を低下させてしまう。
ある不明瞭なメソッドが、10個のピースのうち3個をエンコードするために使用されていた場合、このメソッドを削除することは1個の部分だけが破壊された場合よりも高いインパクトを受ける。

## 6.5 Resilience

透かしに対する攻撃手法には、減算攻撃、加算攻撃、歪曲攻撃の3つがある。

### 6.5.1 Subtractive Attacks

攻撃者が透かしを削除するために、アプリケーションを逆コンパイルすることがある。
いったんコードが逆コンパイルされると、攻撃者はダミーメソッドのような不審なコードを探索できる。
攻撃者が単純な数論の特性に精通している場合、透かしアプリケーションに含まれている不明瞭な述語に気がつく可能性がある。
それらが削除されてもアプリケーションは正常に機能するが、透かしは破壊される。
この手法は常に減算攻撃の影響を受けるが、一般的に知られていないようなより強力な不明瞭な述語を用いることで、攻撃者が透かしの埋め込まれた部分を検出することをより困難にできる。
さらに、用いた不明瞭な述語のライブラリを秘密にすることで、減算攻撃に対する復元力も向上する。

### 6.5.2 Additive Attacks

<!-- textlint-disable -->
加算攻撃は、攻撃者が透かしコードを発見できない、または透かしコードを削除できない場合に用いられる。
この種の攻撃は、オリジナルの透かしの有効性に疑念を抱かせたり、オリジナルをまとめて削除するために用いられる。
表5はGA1、GA2、DGA1、DGA2を用いて透かしを施したテストケースに対して、S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>の他の透かしアルゴリズムを適用した結果を示している。
その結果、元の透かしは追加の透かしを適用してもかなり耐性があることがわかった。
しかし、同じアルゴリズムや他のGAのいずれかを用いて透かしを埋め込むと、元の透かしは破壊された。
これは、認識手順が追加の不明瞭な述語を検出したため発生した。
さらに、GA1を適用してからGA1を、またはGA2を適用してからGA2を、もしくはGA2を適用してからGA1をそれぞれ適用した場合、いずれの透かしも復元不可能であることがわかった。
オリジナルの透かしが破壊されたとしても、攻撃者はこれらの手法を用いて別の透かしを埋め込むことはできない (新しく埋め込まれた透かしも破壊されているため)。
DGA1とDGA2についても、DGA2を適用してからDGA1を適用しても透かしが破壊されないことを除いて同じ結果が得られる。
<!-- textlint-enable -->

### 6.5.3 Distortive Attacks

<!-- textlint-disable japanese/no-doubled-joshi -->
歪曲攻撃とは、コード難読化や最適化など、意味論を維持するコード変換である。
この種の攻撃は、透かしを復元できないように歪めるために行われる。
減算攻撃と比較したときの利点は、攻撃者が透かしの正確な位置を知る必要がないことである。
S<span style="font-size: .7em">AND</span>M<span style="font-size: .7em">ARK</span>内のコード難読化に関して、GA1はGA2よりも耐性があることがわかった。
これは [5] の主張と矛盾する。
筆者は、GA2はメソッドのシグネチャを変更することは難しいため、GA2のほうが強いと主張している。
`Method 2R Madness` と `Primitive Promoter`、`PromoteLocals` という難読手法は、すべてアプリケーション内のメソッドのシグネチャを変更する。
[5] で述べられたオーバーロード手法を実装することで、`Primitive Promoter` や `PromoteLocals` に対する耐性が向上する可能性がある。 
さらに、GA2はメソッドをマージしたり、メソッドの本文を変更したりする攻撃にも弱い。
11のアプリケーションすべてに難読化を適用した結果を表6に示す。
<!-- textlint-enable -->

| 難読化 | GA1 | GA2 |
|:-----:|----:|----:|
| AddBogusFields | 11 | 11 |
| AppendBogusCode | 8 | 0 |
| BlockMarker | 11 | 8 |
| BogusPredicates | 11 | 0 |
| BoolSplitter | 7 | 11 |
| Buggy Code | 11 | 9 |
| Class Splitter | 11 | 11 |
| ConstantPool Reorderer | 3 | 3 |
| FalseRefactor | 11 | 11 |
| Inliner | 11 | 11 |
| InstructionOrdering | 11 | 11 |
| IntArraySplitter | 11 | 11 |
| InterleaveMethods | 11 | 0 |
| LocalVariable Reorderer | 11 | 11 |
| Method 2R Madness | 0 | 0 |
| Method Merger | 11 | 1 |
| Name Obfuscator | 11 | 11 |
| NodeSplitter | 11 | 11 |
| OpaqueBranch | 11 | 10 |
| ParamReorder | 11 | 11 |
| Primitive Promoter | 3 | 0 |
| PromoteLocals | 0 | 0 |
| Publicizer | 11 | 11 |
| Rename Locals | 11 | 11 |
| SetFieldsPublic | 11 | 11 |
| Signature Bludgeoner | 11 | 11 |
| Static Method Bodies | 11 | 11 |
| Thread Contention | 11 | 11 |
| VarSplitter | 11 | 11 |
| Variable Reassigner | 11 | 11 |

**表6: 難読化が施されたアプリケーションから透かしを復元できた数**

本研究における重要な仮定は、攻撃者が透かしを埋め込むために用いられたアルゴリズムを知っているということである。
この仮定に基づくと、GAアルゴリズムはアプリケーション全体のすべてのboolean式に不明瞭な述語を挿入するだけで簡単に攻撃できる。
この攻撃は透かしの認識を妨げ、秘密鍵や埋め込みに使用される不明瞭な述語のライブラリの知識を必要としない。
このような攻撃をcaffeineベンチマークに適用すると、全体で97.5%の速度低下が見られたが、これは透かしが破壊されることを保証するものではない。

アプリケーションに難読化を適用した結果、静的アルゴリズムと動的アルゴリズムの両方が基本的に同じ復元力を持っていることがわかった。
TTTとJKeyboardについて、4つのアルゴリズムのテスト結果を表7に示す。
これらの結果から、歪曲攻撃に対して強い耐性を持っている静的アルゴリズムを変換することで、アルゴリズムの強度を向上させることが示されるわけではない。
しかし、真に動的なアルゴリズムが静的なアルゴリズムよりも本質的に強くないことを示すものでもない。

| 難読化 | | TTT GA1 | TTT GA2 | TTT DGA1 | TTT DGA2 | | JKeyboard GA1 | JKeyboard GA2 | JKeyboard DGA1 | JKeyboard DGA2 |
|:-----:|-|:-------:|:-------:|:--------:|:--------:|-|:-------------:|:-------------:|:--------------:|:--------------:|
| AddBogusFields || + | + | + | + || + | + | + | + |
| AppendBogusCode || + | + | - | - || + | - | - | - |
| BlockMarker || + | + | + | + || + | + | + | + |
| BogusPredicates || + | + | - | + || + | + | - | - |
| BoolSplitter || + | + | + | + || + | + | + | + |
| Buggy Code || + | + | + | + || + | + | + | + |
| Class Splitter || + | + | + | + || + | + | + | + |
| ConstantPool Reorderer || - | + | - | + || + | + | + | + |
| Degrade || - | - | - | - || - | - | - | - |
| FalseRefactor || + | + | + | + || + | + | + | + |
| Inliner || + | + | + | + || + | + | + | + |
| InstructionOrdering || + | + | + | + || + | + | + | + |
| IntArraySplitter || + | + | + | + || + | + | + | + |
| InterleaveMethods || + | + | + | - || + | + | - | - |
| LocalVariable Reorderer || + | + | + | + || + | + | + | + |
| Method 2R Madness || - | - | - | - || - | - | - | - |
| Method Merger || + | + | - | - || + | + | + | + |
| Name Obfuscator || + | + | + | + || + | + | + | + |
| NodeSplitter || + | + | + | + || + | + | + | + |
| OpaqueBranch || + | + | + | + || + | + | + | + |
| ParamReorder || + | + | + | + || + | + | + | + |
| Primitive Promoter || - | - | - | - || - | - | - | - |
| PromoteLocals || - | - | - | - || - | - | - | - |
| Publicizer || + | + | + | + || + | + | + | + |
| Rename Locals || + | + | + | + || + | + | + | + |
| SetFieldsPublic || + | + | + | + || + | + | + | + |
| Signature Bludgeoner || + | + | + | + || + | + | + | + |
| Static Method Bodies || + | + | + | + || + | + | + | + |
| Thread Contention || + | + | + | + || + | + | + | + |
| VarSplitter || + | + | + | + || + | + | + | + |
| Variable Reassigner || + | + | + | + || + | + | + | + |

**表7: GA1、GA2、DGA1、DGA2に難読化を施した結果**

## 6.6 Stealth

ステルス性の評価は主観的である。
現在のところ、ステルス性を定量的に評価する手法は存在しない。
アプリケーションのステルス性を考えるとき、同じアプリケーションの透かし入りと透かしなしのコードを比較することや、他の透かし入りアプリケーションのコードと比較することが最善であることはわかっている。
これらのステルス性の指標はローカルステルスとグローバルステルスと呼ばれる。

ステルス性を評価する方法の1つは、アプリケーションが透かしの挿入前後でどのように変換するかを調べることである。
この手法は定量的な指標を提供しないが、攻撃者にとって疑わしい領域を強調する。
表8は、透かしあり/透かしなしのTTT/JKeyboardの静的統計を示している。
これらの統計から、GA1を用いて透かしを挿入したアプリケーションは元のアプリケーションに非常によく似ていることがわかる。
