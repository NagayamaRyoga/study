# 4 Arboit Algorithm

Arboitは不明瞭な述語を用いた2つの透かし技術を提案した[5]。
1つ目のアルゴリズム (GA1) は、直接不明瞭な述語を用いる単純な挿入アルゴリズムである。
<!-- textlint-disable ja-technical-writing/max-comma -->
透かし\(w\) は \(k\) 個の部分 \(w_0, \dots, w_{k-1}\) に分割され、アプリケーション全体からランダムに選択された \(k\) 個の分岐点 \(b_0, \dots, b_{k-1}\) に埋め込まれる。
<!-- textlint-enable -->
それぞれの分岐点 \(b_i\) について述語 \(\land P_{b_i}^T\)、\(\lor \lnot P_{b_i}^T\)、もしくは \(\lor P_{b_i}^F\) を追加することで透かしの一部を埋め込む。
不明瞭な述語内のbitは定数などにエンコードできる。
透かしの認識時には、アプリケーション内の識別可能なすべての不明瞭な述語を抽出し、その述語から透かしbitをデコードする。
例えば、透かしが不明瞭な述語 \(x^2 \le 0\) にエンコードされるとする。
このとき、透かしは以下のように埋め込まれる。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
}
    ↓ w
class C {
    void m1(int a, int b) {
        ...
        int c = 1;
        if ((a <= b) && (c * c >= 0)) {...}
        else {...}
        ...
    }
} 
```

Arboitの2つ目のアルゴリズム (GA2) は GA1 に似ているが、不明瞭なメソッドを用いて透かしを埋め込むという点が異なる。
\(k\) 個の分岐点 \(b_0, \dots, b_{k-1}\) の各分岐点 \(b_i\) について生成されたメソッド呼び出し \(M_{b_i}^T\) もしくは \(M_{b_i}^F\) が追加される。
透かしbitは、不明瞭な述語を介して不透明な述語にエンコードされる。
透かしの認識時には、すべての不明瞭なメソッドはそのメソッドのシグネチャから抽出される。
候補が特定されると、不明瞭な述語を見つけるためにメソッド本体が検査される。
上記の例と同様の不明瞭な述語を埋め込みに用いるとする。GA2 を用いてアプリケーションは以下のように変換される。

```java
class C {
    void m1(int a, int b) {
        ...
        if (a <= b) {...}
        else {...}
        ...
    }
}
    ↓ w
class C {
    boolean m2() {
        int e = 1;
        return (c * c >= 0);
    }
    void m1(int a, int b) {
        ...
        int c = 1;
        if ((a <= b) && m2()) {...}
        else {...}
        ...
    }
} 
```

Arboitは、メソッドのシグネチャを変更することは難しいため、GA2のほうがセキュアであると述べている。
しかし、この主張は正しくない。SANDMARKにはコード難読化機能が含まれており、シグネチャを変更できる。
Section 6では、実際にGA1がGA2よりも強固であるということを示す。
それによって、ソフトウェア透かしアルゴリズムにおける実装と評価の重要性を実証している。
