# 2. Literature Survey

ソフトウェア透かしは、アプローチと出版物の種類に基づいて様々な方法で分類できる (表1)。
過去23年間 (1996年〜2018年) のソフトウェア透かしに関する研究を表2にまとめる。

**表1: 論文中の表記**

|セクション|形式 (略)|
|:-------|:--------------------|
|アプローチ|Path/branch (PB)<br> reodering (RB)<br> obfuscation (OB)<br> chaos (CB)<br> graph theoretic (GT)<br> opaque predicate (OP)<br> other methods (OT)|
|発表形式|Tool (T)<br> Survey (SV)<br> Reserch (R)<br> Comparative study (CS)|

**表2: ソフトウェア透かしに関する調査**

(省略)


## Reordering-Based Approach

ソフトウェア透かしは Davidson と Myhrvold (1996) によって提案された。
彼らは基本ブロックに透かしを符号化するアルゴリズムを提案した。

Shirali-Shahreza と Shirali-Shahreza (2008) は命令順序の変更によるソフトウェア透かし手法を提案した。
方程式のオペランドを、出力を維持するように透かしに基づいて変更する。
Sha ら (2009) はオペランドの係数の並び替えに基づいてよく似た方法を提案した。
Sha ら (2009) の手法は Shirali-Shahreza と Shirali-Shahreza (2008) の方法と比較して優れている。

Hamilton と Danicic (2011) はコードの並び替えによるソフトウェア透かしに関する調査を発表した。
その後、Sharma ら (2012) は関数従属性指向シーケンス (FDOS) にを用いて方程式を並び替える構造プログラミング用の静的透かし手法を提案した。
数学的にオペランドを交換し、次に非論理的な依存関係を持つ相互に独立した関数へ順序付けを課す。

並び替えに基づく透かしはセマンティックを保つ変換攻撃の影響をとても受けやすい。


## Graph Theoretic‑Based Approach

何人かの研究者はグラフ理論的アプローチを用いたソフトウェア透かし手法を提案した。

1998年、Qu と Potkonjak (1998) はレジスタ割当を用いて透かしを埋め込む手法を提案した。
QPアルゴリズム (Qu と Potkonjak (1998) によって名付けられた) は、グラフ彩色の概念を応用した制約ベースの透かしアルゴリズムである。

Qu と Potkonjak (2000) は彼らの先行研究 (Qu と Potkonjak (1998)) に基づいたフィンガープリント技術を提案した。
QPアルゴリズムは透かしの値に基づいてグラフに辺を追加し、その変更されたグラフを用いてプログラム中の変数間の相互作用をキャプチャする。
彼らは一方向関数を導入し (Qu と Potkonjak 1999)、一方向暗号化関数をメッセージに適用すると、意味のあるメッセージの構築が困難になると主張している。

2004年、Myles と Collberg (2004) は Qu と Potkonjak (1998) に基づいて SANDMARK (Collberg ら 2003b) で新たなQPSアルゴリズムを提案した。
QPSはデータレートが高く、一方で難読化ベースの攻撃などの様々な攻撃を受けやすい傾向にある。

2006年、Zhu と Thomborson (2006b) は透かしを抽出するために元の透かし入りグラフを用いた実際の推論グラフを必要とするQPIという名前のQPアルゴリズムの修正版について述べた。
その後、 (Jiang ら 2009) はQPIと公開鍵暗号を組み合わせた手法を提案した。
彼らは透かしを埋め込む前に暗号化した。

1999年、Collberg らはプログラムの実行中にグラフを生成する動的透かし手法を提案した (Collberg と Thomborson 1999)。
彼らのアプローチに基づき、Krishnaswamy ら (2000) は動的データ構造に透かしを埋め込む手法を提案した。
Krishnaswamy らは Collberg と Thomborson 1999 に基づき、Javaプログラムに透かしを埋め込むための最初の実用的なツールである JavaWiz を開発した。

攻撃者はセマンティクス保存技術によりダミーデータ構造を用意に除去できるため、様々なデータ構造に透かしを埋め込むことは減算攻撃の影響を受けやすい。

Kamel と Albluwi (2009) は R-tree データ構造とその変種に基づいた透かし手法を提案した。
R-tree は保存されたオブジェクトのエントリの順序を用いて冗長性を内部的に維持する。

Venkatesan ら (2001) は透かしの値を格納する特別にマークされたノードを追加することで、CFGの変更に基づいた透かし手法を提案した。
この手法は耐タンパ性の問題を解決することにも適している。
Collberg ら (2009) は Venkatesan ら (2001) によって提案された GTW (Graph-Theoretic Watermarking) アルゴリズムを実装した。

2008年には、Collberg と Thomborson (1999) の弱点をカバーできる閾値ベースの手法が Luo ら (2008) によって提案されている。
その後、Collberg ら (2003a) は2つのグラフベース透かしアルゴリズム (Collberg と Thomborson 1999) と (Venkatesan ら 2001) に焦点を当てている。
その研究によると、Reducible Permutation Graph (RPG) と Planted Planar Cubic trees (PPCTs) がもっとも高い潜在能力を持っている (Collberg ら 2003a)。
PPCTはルートを除いた全てのノードの次数が2の二分木である。
PPCT は耐タンパ定数符号 (Thomborson ら 2004) で値を表現するために用いられる。
PPCTグラフは他のグラフ理論技術に比べビットレートが低く、一方で復元力が高い。

Collberg と Thomborson (1999) は透かしを数値で表現し、グラフトポロジで符号化した。
このトポロジには Radix や 改良PPCT のような構造を用いてもよい。
Krishnaswamy ら (2000) は透かし整数とPPCT構造の関係について述べた。
しかし、透かしとして使用される巨大な整数の表現には失敗している。
そのため、Yong と Yixian (2004) では、radix の視点でPPCTを改良した改良PPCTが提案されている。

He (2002) は動的グラフ透かしシステムに定数符号技術がどのように含まれるかを説明した (He 2002)。

Mishra ら (2008) は Venkatesan ら (2001) が提案した手法とほぼ同様の手法で、Javaクラスのプログラム全体に透かしを埋め込む手法を提案した。
この手法の唯一の違いは、Venkatesan ら (2001) ではコードセグメントに透かしを埋め込んでいるのに対して Mishra ら (2008) の手法ではそれを行っていないことである。

Chan ら (2013) では、JavaScriptプログラム上でのヒープグラフベースのソフトウェアバースマーク技術が用いられている。
彼らは、プログラムと電子透かしの間の意味レベルの統合の欠如が動的透かしの大きな問題であると指摘している。
その後、Chen ら (2017b) は動的なソフトウェア透かしフレームワークを構築するために、制御フロー難読化を導入した。
透かしはいくつかの断片に分割され、各断片は難読化された各分岐に格納する。
興味深いことに、制御フロー難読化は、難読化された分岐を内部プログラムのロジックへ関連付けられた隠された実行パスに接続する。

2015年、Tian ら (2015) はソフトウェアバースマークのための動的キー命令列に基づく手法を開発した。
この命令列は、実行可能コードから抽出でき、コンパイラの最適化や難読化攻撃に耐性を持つ。

別の手法 (Chen ら 2017a) は、Javaのリフレクションを用いて透かしを符号化するために使用されるメソッド名を見つける。

1999年、Pieprzyk (1999) は 分類されたソフトウェアの同一性に関する著作権保護の問題を解決するため、著作権フィンガープリントを用いた。
Collberg ら (2007) によって提案された動的フィンガープリント手法はプログラムの実行中のグラフ内部に埋め込まれる。
これは静的なフィンガープリントと比較して難読化や最適化により耐性を持つ (Collberg ら 2007)。

2010年、Chroni と Nikolopoulos (2010) は電子透かしの整数を self-inverted permutations (SIP) として符号化するアルゴリズムを提案した。
このアルゴリズムは、ある数値をSIPに変換し、SIPから再び数値に変換する処理を O(n) 時間で行う。
また、著者らはSIPを介して透かし整数をグラフに変換する方法も提案している (Chroni と Nikolopoulos 2011b)。
これに基づいて Chroni と Nikolopoulos (2012b) は数値をRPGとして符号化するための効率的な手法を提案した (Chroni と Nikolopoulos 2010)。
その後、透かしグラフを特定の関数を用いてアプリケーションプログラムに埋め込む手法を拡張した (Chroni と Nikolopoulos 2012a)。

Bentoa ら (2014) は、符号化手法やアルゴリズムなどに基づいて、伝統的なRPGの特徴を特徴づけた (Bentoa ら 2014)。
その後 Chionis ら (2013b) は、アプリケ0ションにRPGを用いた動的透かし手法を提案した。


## Obfuscation-Based Approach

2002年、Collberg と Thomborson (2002) はソフトウェアの知的財産に対する3つの異なる種類の攻撃について述べた。

- リバースエンジニアリング
- 海賊版
- 改ざん

それらからの保護は難読化透かしと改ざん防止によって実現される。

Zhu (2007b) はソフトウェア透かしと難読化に関する調査を紹介し、それに続いて透かしの抽出と認識アルゴリズムについて紹介している。

2000年には、SHKQ (Stern-Hachez-Koeune-Quisquater) と名付けられた技術が提案され、x86アセンブリコードに適用された (Stern ら 2000)。
このアルゴリズムは、電子透かしを埋め込むための意味を保つコード変換とコード並べ替えに基づいて透かしを埋め込む。
その後、Collberg と Sahoo (2005) はJavaバイトコードを対象としたSANDMARKフレームワーク (Collberg ら 2003b) に実装することでこれを解析している。 

<!-- textlint-disable -->
難読化に基づくアルゴリズムは、制御グラフをより複雑にし、リバースエンジニアリングを困難にする。
Zeng ら (2010) は様々な攻撃に対抗できる難読化に基づくロバストな手法を提案した。
その後 (Zeng ら 2011) ではこれを修正し、改良された提案と (Stern ら 2000) を比較している。
実験の結果、彼らの提案手法はデータレートがより高く、埋め込みオーバーヘッドがより低いことが示された。
<!-- textlint-enable -->


## Path- or Branch-Based Approach

Collberg ら (2004a) によって導入されたパスベースの透かしは、プログラムの実行時分岐構造に透かしを埋め込む。
このような手法は統計的攻撃の影響を受けにくい。
いくつかの透かし技術は静的攻撃と動的攻撃、またはハイブリッド攻撃のいづれの問題にも対処できない (Madou ら 2005)。
Madou らは、攻撃者がプログラムを変更したり制御したりできる各攻撃の可能性について議論している。

Myles と Jin (2005) は分岐ベースのソフトウェア透かしを導入した。
かれらはcall命令による無条件ジャンプをジャンプ命令のターゲットアドレスを与える fingerpring branch function (FBF) に変換した。
その後、GuptaとPieprzyk (2006) はスタックポインタの変更による低コストの自動攻撃を提案した。
この攻撃はフィンガープリントと完全性チェックを取り除き、MylesとJin (2005) で述べられているようにターゲットアドレスを切り離したプログラムからコードを生成する。

(GuptaとPieprzyk 2007) は (MylesとJin 2005) を元にしており、GuptaとPieprzyk (2006) で言及されているデバッグ攻撃にも耐えられるように改良している。
このアルゴリズムは関数の操作を従来よりも困難にしている。


## Opaque Predicate‑Based Approach

不透過述語よるソフトウェア透かしはCollbergら (1998) によって初めて提案された。
その後、門田ら (2000) はダミーメソッドを用いてJavaソースコードに透かしを埋め込む手法を提案した。
この技術はCollbergら (1998) を改良し、不透過述語を用いてメソッドが呼び出されないようにしている。
このアプローチによって、メソッドがデッドコードとして削除されることを回避できる。
その後、Arboit (2002) は不透過述語を用いたJavaプログラムのための透かし手法を提案した。

Alitavoliら (2013) はデコンパイル・再コンパイル攻撃や難読化攻撃に耐性を持つJavaプログラムのための新しい電子透かし手法を提案した。

MylesとCollberg (2006) はSANDMARK (Collbergら 2003b) で2つの透かし手法を評価した。
その結果、Arboitのアルゴリズム (Arboit 2002) のほうが Collbergのアルゴリズム (Collbergら2003b) よりも耐障害性やステルス性のようないくつかの特性について強力であると結論づけた。
さらに、著者らは動的手法が静的手法よりも本質的に強いかどうかを探った。
Chionisら (2013a) はプログラムの特定の関数呼び出しのフローを制御するために特定の制御分の中で不透過述語を用いた。


## Chaos‑Based Approach

カオス暗号による電子透かしはKe-xinら (2009) によって定義された。
彼らは、シャミール閾値とカオス暗号化に基づく電子透かし技術を紹介している。
そのため、実際の透かしを抽出するためには最小限の情報しか必要としない。
この手法はBLOAT (Bytecode-level Optimizer and Analysis Tool) (Nystrom 1998) や加算攻撃を除いて、様々な攻撃に耐性を持つ。
同様にLiuら (2006) はイースターエッグから構想を得たanti-reversing技術を用いた透かし手法を提案した。
このカオスシステムでは、プログラム全体に透かしを分散させ、プログラム全体の保護を実現している。
電子透かしは実行コードに適用されるため、再コンパイルの必要がない。


## Others Algorithms

BhattacharyaとCortesi (2010) はC言語のソースコードに透かしを埋め込むための手法を提案した。
この手法は、意味論に基づいてソースコード内の関数に対して隠された順列処理を行う。
この手法は、透かし構築技術とその埋め込み位置を隠蔽するため、衝突攻撃への耐性がある。
同様に、ゼロ透かしは追加ノードを持たない透かし情報を埋め込む (XuとXiang 2012)。
この手法は透かし情報をコード難読化によって隠す。

CousotとCousot (2004) は、プログラムセマンティクスの静的解析がフィンガープリントを
公開する抽象解釈ベースのフィンガープリント手法について述べている。

NagraとThomborson (2004) は様々なスレッド、ロック、スレッド競合に基づいた透かし手法を提案した。

Thaker (2004) はメタモルフィック・ウイルスの動作原理に着想を得た方式を提案した。
これにより、機能的に等価な別個の透かしプログラムが生成され、いくつかの攻撃に対してより高い耐性を持つようになる。

Gilら (2006) は構文構造に基づいてプログラムを圧縮する新たな線形時間圧縮アルゴリズムを開発した。
プログラムを圧縮しながら作成される表をフィンガープリントとみなす。
また、LZWアルゴリズムを用いたフィンガープリントの自動検出機構も示した。
LZWは識別子の感度が高いため、プログラムの意味論を扱えない。
その結果、Coxら (2000) はロバスト性、コスト、ご検出率などの電子透かし特性と電子透かしアプリケーションとの関係について述べている。

いくつかのソフトウェア透かしは目的とその特性に基づいて分類されている (Nagraら 2002)。
別の有用な調査 (Zhuら 2005) では、ソフトウェア透かしの分類、攻撃モデル、およびアルゴリズムが記述されている。
Mylesら (2005) はSANDMARK (Collbergら 2003b) において、基本的な透かしの特性に基づいて、2つの透かし手法 (DavidsonとMyhrbold 1996) と (門田ら 2000) を経験的に評価している。
同様に、Sionらは復元力のある情報隠蔽による数値データセット上の基本的な問題について述べている (Sionら 2002)。
Hamiltonらは静的なソフトウェア透かしのアプローチに関する分類的な調査を提示している。

ZhuとThomborson (2006a) は、抽出可能な埋め込みアルゴリズムを特徴づける代表集合と度数について述べている。
その後、Zhuは (ZhuとThomborson 2006a) を改良し、埋め込みアルゴリズムに対するインフォームド認識の概念を定義した (Zhu 2007a)。

Javaプログラムのための別の透かしフレームワークは、信号検出モデルを用いている (Curranら 2003)。

Yuら (2012) はクラウドプラットフォームにおけるソフトウェア保護のための手法を提案した。

例外処理に基づく動的ソフトウェア透かし手法 (Wangら 2018) はバイナリ電子透かしを例外入力シーケンスとしてエンコードする。
これは、トリガー条件と例外処理コードを用いてソースコードに埋め込まれる。


## Software Watermarking Tools

現在にソフトウェア透かしに関する研究で主に用いられているソフトウェア透かしツールを表3に示す。

**表3: ソフトウェア透かしツール**

|ツール     | ホスト言語    | 目的      |
|:---------|:------------|:----------|
|JavaWiz Collberg and Thomborson (1999)| Javaコード |いくつかの透かし手法の実験とテスト|
|Sandmark Collberg et al. (2003b) | Javaバイトコード |ソフトウェア透かし、耐タンパ性、コード難読化|
|Hydan El-Khalil and Keromytis (2004) |x86プログラム |x86アセンブリの冗長性を用いてメッセージを隠蔽|
|UWStego Collberg et al. (2004b) |x86プログラム |透かしの埋め込まれたJavaプログラムユーザ|
|Jmark Jdecode| Javaクラスファイル |Javaクラスファイルへの透かしの埋め込み・抽出 |
|Jbirth |Javaクラスファイル |Javaクラスファイルからのバースマーク抽出と比較 |
