# 3. Architecture

Hydanはメッセージ (埋め込む情報) と実行可能ファイルを入力として受け取り、ステガノグラフィでメッセージが埋め込まれた機能的に等価な実行可能ファイルを出力する。

機械語命令セット(i386プロセッサファミリー命令セットなど) に固有の冗長性を用いてメッセージを符号化する。すなわち、いくつかの命令は複数の方法で表現できる。

例えば、`eax` レジスタに `50` を足すことは、`add %eax, $50` と `sub %eax, $-50` という2つの表現ができる。
このような2つの代替表現を使用して、実行可能ファイル内に加算または減算が現れたときにはいつでも1bitの情報を符号化できる。

別の例は、レジスタ `XOR` でゼロクリアするとき、これは `sub` 命令で自身を減算することでも同様の効果が得られる。
例えば表1のOriginal codeで示されるコードを考える。

```
 Original code                   Encoding 00
+-----------------------------+ +-----------------------------+
| 83 e8 30  sub  %eax, $0x30  | | 83 c0 d0  add  %eax, $-0x30 |
| 83 f8 36  cmp  %eax, $0x36  | | 83 f8 36  cmp  %eax, $0x36  |
| 77 e5     ja   %-27         | | 77 e5     ja   %-27         |
| 83 c0 08  add  %eax, $0x8   | | 83 c0 08  add  %eax, $0x8   |
| 89 04 24  mov  %eax, [%esp] | | 89 04 24  mov  %eax, [%esp] |
+-----------------------------+ +-----------------------------+

 Encoding 01                     Encoding 11
+-----------------------------+ +-----------------------------+
| 83 c0 d0  add  %eax, $-0x30 | | 83 c0 d0  add  %eax, $-0x30 |
| 83 f8 36  cmp  %eax, $0x36  | | 83 f8 36  cmp  %eax, $0x36  |
| 77 e5     ja   %-27         | | 77 e5     ja   %-27         |
| 83 e8 f8  sub  %eax, $-0x8  | | 83 e8 f8  sub  %eax, $-0x8  |
| 89 04 24  mov  %eax, [%esp] | | 89 04 24  mov  %eax, [%esp] |
+-----------------------------+ +-----------------------------+
```
**表1. 等価な命令を用いた `00`, `01`, `11` の符号化**

データを符号化するために用いられる別の特徴は、いくつかの命令が２つの形式を持つことである。
例えば、`insn r/m, reg` と `insn reg, r/m`, の `reg` はレジスタを表し、`r/m` はレジスタとメモリ上のアドレスの双方を表すことができる。
`r/m` がレジスタを指すとき、オペコードを変更し `reg` と `r/m` の値を入れ替えることで、命令はどちらの形式を用いても符号化できる。

1つの命令に1bitよりも多くの情報を符号化できることもある。
`n` 個の等価な表現が命令に存在するとき、それらを用いて $\log_2(n)$ bit の情報を符号化出来る。
4つの表現から命令を選択するとき、2bitの情報を埋め込める。
等価な表現が存在するとき、通常その数は2つまたは4つである。
これら2つの場合、我々は7個の等価な命令からなる集合を発見できた。

しかし、7個の命令では3bitを符号化するには十分ではない ($2^3 = 8$ 個の命令が必要になる)が、2bitを符号化するには多すぎる。
4個の命令のみを使用して他の3つの命令を無駄にしないように、集合のうち1つの命令をワイルドカードにする符号化方式を考案した。

この命令は現在の命令セットで直接表現できない値が出現したときに使用される。

例えば、7命令の集合を考える。
このとき、0から5の (ワイルドカード命令を除く6つの数値) 数値を符号化できる。
しかし、6から8を符号化することはできない。
そこで、ワイルドカード命令を使用してこの命令がデータを符号化しないことを示し、その次の埋め込み対象の命令でデータを埋め込むようにする。
7命令の例では約 $log_2 6= 2.58$ bit を埋め込むことができる。


一般に、等価な命令の個数nが2のべき乗でない場合、$log_2(n-1)$ bit を埋め込むことができる。

<!-- textlint-disable preset-japanese/no-doubled-joshi -->
これは埋め込むデータが一様分布するときうまく機能する。
これを確実にするため、(情報隠蔽アプリケーションで一般的に行われているようにメッセージをさらに安全にするため)埋め込む前にデータを暗号化しておおよそ一様分布になるようにする。
AESやBlowfishなどの優れたブロック暗号化アルゴリズムで生成された暗号文にこの特性がある。
<!-- textlint-enable preset-japanese/no-doubled-joshi -->

<!-- textlint-disable preset-japanese/no-doubled-joshi -->
簡単のために、同じサイズの命令を置換する場合のみを考えた。
複数の命令からなるなどでより大きい命令サイズが必要になる等価な変換は、後続のジャンプ命令や関数呼び出しのアドレス、データの位置や参照などがすべてずれてしまうためである。
これは不可能ではないが、特にx86のディスアセンブルは注意が必要なので符号化プロセスが著しく複雑になる。
<!-- textlint-enable preset-japanese/no-doubled-joshi -->

この手法の長所はプログラムのコードサイズが変化しないことである。

さらに、等価な集合に属するすべての命令はすべて同じ効果を有するが、プロセッサフラグの設定などで異なる副作用をもつ場合がある。
例えば、加算と減算でcarryフラグとoverflowフラグの設定は異なる。

そのため、Hydanは置換された命令が悪影響を及ぼす可能性のあるすべてのフラグを考慮する。
その命令に続く命令をスキャンして、フラグの違いが実行結果に影響を及ぼすかを確認する。

置換された命令に続く各命令をみて、それが変更されたフラグを使用するかを確認する。
実行フローに従って、その関数の終わりもしくは追跡しているフラグを変更する命令が実行されるまで確認する。
すべての変更されたフラグが他の命令から参照されていなければ、その命令は置換しても安全である。
そうでなければ、埋め込みは行われない。
幸運なことにそのような例は0.2%程度と稀である。

## 埋め込みプロセス

埋め込みプロセスそれ自体は簡単である。

エンコードされるメッセージと対応する隠しテキストを読むと、Hydanはユーザーにメッセージの暗号化に使用するキーを要求する。
次にHydanはメッセージのサイズを先頭に追加し、BlowfishのCBCモードでデータを暗号化する。
メッセージの長さはデコードのために必要だが、バイナリ中の隠しデータの存在を検出する手段として使用されないように暗号化される。

<!-- textlint-disable preset-ja-technical-writing/no-exclamation-question-mark -->
メッセージ長は64bitの値であり、そのMSB(最上位bit? Byte?)は基本的にすべて0である。
これは暗号解析を容易になる (MSBが0という情報を利用して、ユーザーの指定したパスフレーズから派生したBlowfishセッションキーに対する辞書攻撃が可能になる)。
そのため"whitening step"として、暗号化する前にその長さをパスフレーズのハッシュ値とXORする。
<!-- textlint-enable preset-ja-technical-writing/no-exclamation-question-mark -->

暗号化ステップが完了すると、Hydanはすべてのコードセクション内の、埋め込みに用いることのできる命令の位置を決定する。
ELF実行可能ファイルは複数のコードセクションを持つことができるが、`a.out`やPE/COFF実行可能ファイルはただ1つのコードセクションしか持つことができない。

最初のコードセクションで、ランダムなbit数命令をスキップしてから埋め込みを始める。
そのランダムな量はユーザのキーをシードとして定める。
その目的は検出のための作業負荷を増やすためである。
スキップするbit数は、$[0, 2 \cdot \omega_c / \omega_m]$ の範囲で決定する。
ここで、$\omega_c$ は"covertext"に残りのbit数、$\omega_m$ はメッセージ $m$ の残りのbit数である。
この間隔は8bit埋め込むごとに更新される。

## デコードプロセス

メッセージを抽出するために、Hydanはユーザの決めたパスワードを使用してスキップするbit数を決定し、最初に埋め込みデータのサイズを抽出する。
まずこのサイズは復号され、次に"covertext"から関連するデータ量を抽出する。
ランダムスキップの間隔など、乱数から得られる値が符号化プロセスと同一になるように注意を払う。
