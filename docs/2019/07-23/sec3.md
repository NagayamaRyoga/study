# 3. Embedding and Extracting

ソフトウェア透かしでは2つの基本的なことを行わなければならない。

1. ソフトウェアオブジェクトに対して埋め込みを行うこと
2. それによってソフトウェアに埋め込まれたすべての透かしbitを抽出する、もしくは埋め込まれた透かしが存在するか否かを認識すること

本章では、ソフトウェア透かしの埋め込みと抽出に関するいくつかの概念について紹介する。
これらに関しては我々の以前の研究[46]ですでに述べられている。

Section 4 で取り上げる認識問題に関する議論では、抽出に関する問題についての概念が必要になるがそれらはこの論文の焦点ではない。

## 3.1. Embedding

正確さを欠いて簡単に説明するならば、ソフトウェアに透かしを埋め込むことはプログラムのコードに秘密情報を挿入することである。
この概念を以下のように、形式的に定義する。

### Definition 1. (Watermark)

透かしは長さ0以上の有限長のbit列からなるメッセージである。
すべての透かしの集合を $\bf{W}$ とする。

### Definition 2. (Embedding)

$\bf{P}$ をプログラムの集合、$\bf{W}$ を透かしの集合とする。
関数 $A: \bf{P} \times \bf{W} \longrightarrow \bf{P}$ を透かし埋め込みアルゴリズム、あるいは単に埋め込み器と呼ぶ。
ある$P \in \bf{P}$、$W \in \bf{W}$ について、$P' = A(P, W)$ は (埋め込み器 $A$ に関して) 透かし入りプログラムであると呼ばれる。
また、$P$ は $P'$ のオリジナルプログラムと呼ばれる。

本論文で定義された概念について説明するため、具体的なソフトウェア透かしアルゴリズムである QPアルゴリズム を例に上げて説明する。

## 3.2. The QP Watermarking Algorithm

Qu と Potkonjak は グラフ彩色 (GC: Graph Coloring) 問題[30][31]の *watermarking solution* であるQPアルゴリズム[21][39][40]と呼ばれる透かしアルゴリズムを提案した。
このアルゴリズムはグラフの頂点にインデックスをつける必要がある。
つまり、各頂点は固有の整数 $1$ から $\|V(G)\|$ でラベル付けされる。
QPアルゴリズムはノードのインデックスの順序付けに大きく依存する。
以下はQPアルゴリズムで使用される概念である。

### Definition 3. 循環剰余 $n$ の順序[30][31]

記号 $<_i$ で、ある数 $i$ についての循環剰余 $n$ の順序付けを $i <_i (i+ 1) <_i ...<_i n <_i 1 <_i ··· <_i i−1$ のように表現する。
混乱がない場合には $<_i$ の添字 $i$ を省略する。

### Definition 4. 頂点 $v_i$ に接続していない2つの最近傍頂点[30, 31]

$\|V\|=n$ であるグラフ $G$ の頂点 $v_i$ について、$v_{i_1}, v_{i_2} \in V$ が以下を満たすとき、$v_{i_1}$、$v_{i_2}$ を $v_i$ に接続していない最近傍頂点であるという。

- $i <_i i_1 <_i i_2$
- $(v_i, v_{i_1}) \notin E$ かつ $(v_i, v_{i_2}) \notin E$
- 任意の $j, i <_i j <_i i_1$ について $(v_i, v_j) \in E$
- 任意の $j, i_1 <_i j <_i i_2$ について $(v_i, v_j) \in E$
